#!/usr/bin/env python
# This program helps to perform power operations
# on IPMI-enabled hosts via Foreman.
# Authors:
#  Nacho Barrientos <nacho.barrientos@cern.ch>
# July 2013

# Exit codes:
#  0 all power operations succeeded
#  1 some power operations failed
#  2 bad command line
#  3 current TGT is not valid or missing
#  4 failed to obtain/load a SSO cookie
#  5 failed to remove temporary cookie jar

import sys
import os
import re
import argparse
import tempfile
import socket
import logging
import time
import functools
import json
import cookielib
import requests
import multiprocessing

from subprocess import Popen, PIPE

class AiRemotePowerControlError(Exception):
    pass

VALID_OPERATIONS=("on", "off", "soft", "cycle", "status")
DEFAULT_OPERATION=("status")
DEFAULT_LOGGING_LEVEL=logging.ERROR
DEFAULT_FOREMAN_HOSTNAME = "judy.cern.ch"
DEFAULT_FOREMAN_PORT = 443
DEFAULT_COOKIEJAR_LOCATION = os.path.expanduser("~")
CERN_CA_BUNDLE = "/etc/ssl/certs/CERN-bundle.pem"

def timed(f):
    """Decorator to output the time spent executed a given function"""
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = f(*args, **kwargs)
        elapsed = time.time() - start
        logging.debug("Executed '%s' in %.2f ms" % (f.__name__, elapsed*1000))
        return result
    return wrapper

def __execute_command(args):
    logging.debug("Executing %s" % args)
    process = Popen(args, stdout=PIPE, stderr=PIPE)
    (stdout, stderr)  = process.communicate()
    returncode = process.returncode
    return (process.returncode, stdout, stderr)

@timed
def validate_tgt():
    """Checks if there's a valid TGT in the environment"""
    status, stdout, stderr = __execute_command(["klist", "-s"])
    if status != 0:
        raise AiRemotePowerControlError("kinit -s returned non-zero")

@timed
def get_sso_cookiejar():
    """Gets a cookie jar for Foreman via cern-get-sso-cookie"""
    if args.cookiejar_path:
        return args.cookiejar_path
    try:
        fd, cookiejar_path = tempfile.mkstemp(
            suffix="foreman-cookiejar-%s" % socket.gethostname(),
            dir=args.cookiejar_basepath)
        os.close(fd)
    except OSError, error:
        raise AiRemotePowerControlError("Can't create temporary file for the cookie jar")

    status, stdout, stderr = __execute_command(["cern-get-sso-cookie",
        "--krb", "-u", "https://%s" % args.hostname, "-o",
        cookiejar_path, "-r"])
    if status != 0:
        raise AiRemotePowerControlError("Failed to get cookiejar (%s)" % stderr)

    return cookiejar_path

def format_output(summary):
    """Formats the output based on the output format specified"""
    if args.errors:
        summary = filter(lambda x: not x['success'], summary)
    if args.json:
        print json.dumps(summary)
    else:
        for fqdn in summary:
            sys.stdout.write("%s: " % fqdn['fqdn'])
            if fqdn['success'] and args.operation == "status":
                print fqdn['details']
            elif fqdn['success']:
                print "Command sent"
            else:
                print "Error (%s)" % fqdn['details']

@timed
def foreman_power_operation(fqdn):
    """Performs a power operation on the passed fqdn"""
    logging.debug("Executing '%s' on host '%s'" % (args.operation, fqdn))
    ipmifqdn = re.sub(r'\.cern\.ch$', "-ipmi.cern.ch", fqdn)
    url="https://%s:%u/api/hosts/%s/interfaces/%s/power" % \
        (args.hostname, args.port, fqdn, ipmifqdn)
    payload = json.dumps({'power_action': args.operation})
    headers = {'Content-type': 'application/json',
        'Accept': 'application/json, version=2',
        'User-Agent': 'ai-remote-power-control'}
    try:
        response = requests.put(url, data=payload, 
            headers=headers, cookies=cookiejar,
            verify=CERN_CA_BUNDLE, allow_redirects=False)
        if response.status_code == requests.codes.ok:
            msg = ""
            if args.operation == "status":
                msg = json.loads(response.text)["power"].upper()
            return (True, msg)
        elif response.status_code == requests.codes.found or \
            response.status_code == requests.codes.unauthorized:
                return (False, "Authentication failed")
        elif response.status_code == requests.codes.not_found:
            return (False, "Host not in Foreman or without an IPMI interface (VM?)")
        elif response.status_code == requests.codes.internal_server_error:
            return (False, "ISE. Open a bug against Foreman")
        else:
            return (False, "Uncontrolled status code (%s), please report a bug" %
                response.status_code)
    except requests.exceptions.ConnectionError, error:
        return (False, "Connection error (%s)" % error)
    except requests.exceptions.Timeout, error:
        return (False, "Connection timeout")

def configure_logging():
    """Configures application log level based on cmdline arguments"""
    logging_level = DEFAULT_LOGGING_LEVEL
    if args.verbose:
        logging_level = logging.DEBUG
    logging.basicConfig(level=logging_level, format="%(message)s")

def parse_cmdline_args():
    """Parses and validates cmdline arguments"""
    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--operation',
        help="Power operation to perform (%s) (default: %s)" % \
            (", ".join(VALID_OPERATIONS), DEFAULT_OPERATION),
        default=DEFAULT_OPERATION)
    parser.add_argument('-j', '--json',
        action="store_true",
        help="Produce JSON output")
    parser.add_argument('-v', '--verbose',
        action="store_true",
        help="Be chatty")
    parser.add_argument('-e', '--errors-only', dest="errors",
        action="store_true",
        help="Outputs errors only")
    parser.add_argument('--foreman-hostname', dest="hostname",
        help="Foreman hostname (default: %s)" % DEFAULT_FOREMAN_HOSTNAME,
        default=DEFAULT_FOREMAN_HOSTNAME)
    parser.add_argument('--foreman-port', dest="port", type=int,
        help="Foreman port (default: %s)" % DEFAULT_FOREMAN_PORT,
        default=DEFAULT_FOREMAN_PORT)
    parser.add_argument('-t', '--threads', type=int,
        choices=xrange(1, (multiprocessing.cpu_count()*2)+1),
        help="Number of threads (default: #cores) (max: #cores*2)",
        default=multiprocessing.cpu_count())
    parser.add_argument('-c', '--cookiejar-basepath', dest="cookiejar_basepath",
        help="Directory where the cookiejar will temporary live (default: %s)" % \
            DEFAULT_COOKIEJAR_LOCATION,
        default=DEFAULT_COOKIEJAR_LOCATION)
    parser.add_argument('-r', '--reuse-cookiejar', dest="cookiejar_path",
        help="Path to a cookiejar generated with cern-get-sso-cookie to reuse")
    parser.add_argument('fqdns', nargs='+',
        help="One of more FQDNs",
        metavar="FQDN")
    args = parser.parse_args()
    if args.operation not in VALID_OPERATIONS:
        parser.error("Operation '%s' not valid. See --help." % args.operation)
    return args

def process_fqdn(fqdn):
    logging.debug("Processing '%s'" % fqdn)
    fqdn_summary = {'fqdn': fqdn, 'success': False}

    if re.match(r".+?\.cern\.ch$", fqdn) is None:
        fqdn_summary['details'] = "Invalid FQDN"
    else:
        fqdn_summary['success'], fqdn_summary['details'] = \
            foreman_power_operation(fqdn)

    return fqdn_summary

def main():
    """Application entrypoint"""
    global args
    args = parse_cmdline_args()
    configure_logging()

    logging.debug("Validating TGT...")
    try:
        validate_tgt()
    except AiRemotePowerControlError, error:
        logging.error("TGT expired or non-existent")
        return 3

    logging.debug("Getting SSO cookie...")
    try:
        cookiejar_path = get_sso_cookiejar()
    except AiRemotePowerControlError, error:
        logging.error("SSO: %s" % error)
        return 4

    logging.debug("Loading cookie jar into memory...")
    global cookiejar
    cookiejar = cookielib.MozillaCookieJar(cookiejar_path)
    try:
        cookiejar.load()
    except (cookielib.LoadError, IOError), error:
        logging.error("Unable to read cookies from '%s'" % cookiejar_path)
        return 4

    pool = multiprocessing.Pool(processes=args.threads)
    summary = pool.map(process_fqdn, args.fqdns)
    pool.close()
    pool.join()

    if not args.cookiejar_path:
        logging.debug("Removing cookie jar '%s'..." % cookiejar_path)
        try:
            os.remove(cookiejar_path)
        except OSError, error:
            logging.error("Unable to remove cookie jar '%s'" % \
                (cookiejar_path, error))
            return 5

    format_output(summary)

    failures = reduce(lambda x, y: x+1 if y['success'] is False else x, summary, 0)
    if failures:
        return 1
    return 0

if __name__ == '__main__':
    sys.exit(main())
