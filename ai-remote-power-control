#!/usr/bin/env python
# This program helps to perform power operations
# on IPMI-enabled hosts via Foreman.
# Authors:
#  Nacho Barrientos <nacho.barrientos@cern.ch>
# July 2013

# Exit codes:
#  0 all power operations succeeded
#  1 some power operations failed
#  2 bad command line

import sys
import os
import re
import argparse
import tempfile
import socket
import logging
import time
import functools
import json
import requests
import multiprocessing
from requests_kerberos import HTTPKerberosAuth

class AiRemotePowerControlError(Exception):
    pass

VALID_OPERATIONS=("on", "off", "soft", "cycle", "status")
DEFAULT_OPERATION=("status")
DEFAULT_LOGGING_LEVEL=logging.ERROR
DEFAULT_FOREMAN_HOSTNAME = "judy.cern.ch"
DEFAULT_FOREMAN_PORT = 8443
CERN_CA_BUNDLE = "/etc/ssl/certs/CERN-bundle.pem"

def timed(f):
    """Decorator to output the time spent executed a given function"""
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = f(*args, **kwargs)
        elapsed = time.time() - start
        logging.debug("Executed '%s' in %.2f ms" % (f.__name__, elapsed*1000))
        return result
    return wrapper

def format_output(summary):
    """Formats the output based on the output format specified"""
    if args.errors:
        summary = filter(lambda x: not x['success'], summary)
    if args.json:
        print json.dumps(summary)
    else:
        for fqdn in summary:
            sys.stdout.write("%s: " % fqdn['fqdn'])
            print fqdn['details'] if fqdn['success'] \
                else "Error (%s)" % fqdn['details']

@timed
def foreman_power_operation(fqdn):
    """Performs a power operation on the passed fqdn"""
    logging.debug("Executing '%s' on host '%s'" % (args.operation, fqdn))
    ipmifqdn = re.sub(r'\.cern\.ch$', "-ipmi.cern.ch", fqdn)
    url="https://%s:%u/api/hosts/%s/interfaces/%s/power" % \
        (args.foreman_hostname, args.foreman_port, fqdn, ipmifqdn)
    payload = json.dumps({'power_action': args.operation})
    headers = {'Content-type': 'application/json',
        'Accept': 'application/json, version=2',
        'User-Agent': 'ai-remote-power-control'}
    try:
        response = requests.put(url, data=payload, 
            headers=headers, auth=HTTPKerberosAuth(),
            verify=CERN_CA_BUNDLE, allow_redirects=True)
        if response.status_code == requests.codes.ok:
            outcome = json.loads(response.text)["power"]
            if args.operation == "status":
                return (True, outcome.upper())
            else:
                if outcome is False:
                    return (False, "Failed to send IPMI power operation")
                else:
                    return (True, "Command sent")
        elif response.status_code == requests.codes.forbidden or \
            response.status_code == requests.codes.unauthorized:
                return (False, "Authentication failed (expired or non-existent TGT?)")
        elif response.status_code == requests.codes.not_found:
            return (False, "Host not in Foreman or without an IPMI interface (VM?)")
        elif response.status_code == requests.codes.internal_server_error:
            return (False, "ISE. Open a bug")
        else:
            return (False, "Uncontrolled status code (%s), please report a bug" %
                response.status_code)
    except requests.exceptions.ConnectionError, error:
        return (False, "Connection error (%s)" % error)
    except requests.exceptions.Timeout, error:
        return (False, "Connection timeout")

def configure_logging():
    """Configures application log level based on cmdline arguments"""
    logging_level = DEFAULT_LOGGING_LEVEL
    if args.verbose:
        logging_level = logging.DEBUG
    logging.basicConfig(level=logging_level, format="%(message)s")

def parse_cmdline_args():
    """Parses and validates cmdline arguments"""
    parser = argparse.ArgumentParser()
    parser.add_argument('-j', '--json',
        action="store_true",
        help="Produce JSON output")
    parser.add_argument('-v', '--verbose',
        action="store_true",
        help="Be chatty")
    parser.add_argument('-e', '--errors-only', dest="errors",
        action="store_true",
        help="Outputs errors only")
    parser.add_argument('--foreman-hostname', dest="foreman_hostname",
        help="Foreman hostname (default: %s)" % DEFAULT_FOREMAN_HOSTNAME,
        default=DEFAULT_FOREMAN_HOSTNAME)
    parser.add_argument('--foreman-port', dest="foreman_port", type=int,
        help="Foreman Kerberos port (default: %s)" % DEFAULT_FOREMAN_PORT,
        default=DEFAULT_FOREMAN_PORT)
    parser.add_argument('-t', '--threads', type=int,
        choices=xrange(1, (multiprocessing.cpu_count()*2)+1),
        help="Number of threads (default: #cores) (max: #cores*2)",
        default=multiprocessing.cpu_count())
    parser.add_argument('operation', nargs=1,
        help="Power operation to perform (%s)" % ", ".join(VALID_OPERATIONS))
    parser.add_argument('hostname', nargs='+',
        help="One of more hostnames (qualified or not) separated by comma or blank")
    args = parser.parse_args()
    args.operation = args.operation[0]
    if args.operation not in VALID_OPERATIONS:
        parser.error("Operation '%s' not valid. See --help." % args.operation)
    return args

def process_fqdn(fqdn):
    logging.debug("Processing '%s'" % fqdn)
    fqdn_summary = {'fqdn': fqdn, 'success': False}

    if re.match(r".+?\.cern\.ch$", fqdn) is None:
        fqdn_summary['details'] = "Unable to resolve FQDN"
    else:
        fqdn_summary['success'], fqdn_summary['details'] = \
            foreman_power_operation(fqdn)

    return fqdn_summary

def main():
    """Application entrypoint"""
    global args
    args = parse_cmdline_args()
    configure_logging()

    args.hostname = reduce(list.__add__, map(lambda x: x.split(','), \
        args.hostname), [])
    fqdns = map(socket.getfqdn, args.hostname)
    pool = multiprocessing.Pool(processes=args.threads)
    summary = pool.map(process_fqdn, fqdns)
    pool.close()
    pool.join()

    format_output(summary)

    failures = reduce(lambda x, y: x+1 if y['success'] is False else x, summary, 0)
    if failures:
        return 1
    return 0

if __name__ == '__main__':
    sys.exit(main())
