#!/usr/bin/env python
# This program helps to kill a puppet-managed
# Foreman-enabled Openstack VM
# Authors:
#  Nacho Barrientos <nacho.barrientos@cern.ch>

# Exit codes:
#  0 all operations succeeded
#  1 some operations failed
#  2 bad command line
#  3 bad user environment
#  3 Kerberos TGT not found or expired

import os
import sys
import logging
import argparse
import re
import socket
import json
import requests
import krbV
from requests_kerberos import HTTPKerberosAuth
import novaclient.exceptions
from novaclient.v1_1 import client

DEFAULT_LOGGING_LEVEL=logging.ERROR
DEFAULT_NOVA_TIMEOUT = 15
DEFAULT_FOREMAN_TIMEOUT = 15
DEFAULT_FOREMAN_HOSTNAME = "judy.cern.ch"
DEFAULT_FOREMAN_PORT = 8443
CERN_CA_BUNDLE = "/etc/ssl/certs/CERN-bundle.pem"

class AiKillVmError(Exception):
    pass

class AiKillVmNovaError(AiKillVmError):
    pass

class AiKillVmForemanError(AiKillVmError):
    pass

def configure_logging():
    """Configures application log level based on cmdline arguments"""
    logging_level = DEFAULT_LOGGING_LEVEL
    if args.verbose:
        logging_level = logging.DEBUG
    logging.basicConfig(level=logging_level, format="%(message)s")

def verify_environment():
    for variable in ("OS_USERNAME", "OS_PASSWORD", \
           "OS_TENANT_NAME", "OS_AUTH_URL"):
        if variable not in os.environ:
            raise AiKillVmError("%s not set (openrc not (or partially) sourced?)" % variable)

def verify_kerberos():
    context = krbV.default_context()
    ccache = context.default_ccache()
    try:
        ccache.principal()
    except krbV.Krb5Error:
        raise AiKillVmError("Kerberos principal not found")

def parse_cmdline_args():
    """Parses and validates cmdline arguments"""
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--verbose',
        action="store_true",
        help="Be chatty")
    parser.add_argument('-d', '--dryrun',
        action="store_true",
        help="Don't do the actual deletion requests")
    parser.add_argument('-j', '--json',
        action="store_true",
        help="Produce JSON output")
    parser.add_argument('-e', '--errors-only', dest="errors",
        action="store_true",
        help="Outputs errors only")
    parser.add_argument('--nova-timeout', type=int,
        help="Timeout for OpenStack operations (default: %s seconds)" % \
        DEFAULT_NOVA_TIMEOUT,
        default = DEFAULT_NOVA_TIMEOUT)
    parser.add_argument('--foreman-timeout', type=int,
        help="Timeout for Foreman operations (default: %s seconds)" % \
        DEFAULT_FOREMAN_TIMEOUT,
        default = DEFAULT_FOREMAN_TIMEOUT)
    parser.add_argument('--foreman-hostname',
        help="Foreman hostname (default: %s)" % DEFAULT_FOREMAN_HOSTNAME,
        default=DEFAULT_FOREMAN_HOSTNAME)
    parser.add_argument('--foreman-port', type=int,
        help="Foreman Kerberos port (default: %s)" % DEFAULT_FOREMAN_PORT,
        default=DEFAULT_FOREMAN_PORT)
    parser.add_argument('hostname', nargs='+',
        help="One of more hostnames (qualified or not)")
    args = parser.parse_args()
    return args

def format_output(summary):
    """Formats the output based on the output format specified"""
    if args.errors:
        summary = filter(lambda x: not x['success'], summary)
    if args.json:
        print json.dumps(summary)
    else:
        for element in summary:
            sys.stdout.write("%s: " % element['hostname'])
            print "Deleted" if element['success'] \
                else "Error (%s)" % element['details']

def delete_virtual_machine(hostname):
    vmname = re.sub("\.cern\.ch$", "", hostname)
    logging.debug("Deleting virtual machine '%s'..." % vmname)
    tenant = client.Client(os.environ["OS_USERNAME"],
        os.environ["OS_PASSWORD"],
        os.environ["OS_TENANT_NAME"],
        auth_url=os.environ["OS_AUTH_URL"],
        cacert=CERN_CA_BUNDLE,
        service_type="compute",
        timeout=args.nova_timeout)

    logging.debug("Auth URL: %s" % os.environ["OS_AUTH_URL"])
    logging.debug("Username: %s" % os.environ["OS_USERNAME"])
    logging.debug("Nova timeout: %d" % args.nova_timeout)

    try:
        filtered_servers = filter(lambda x: x.name == vmname, tenant.servers.list())
        if len(filtered_servers) == 0:
            raise AiKillVmNovaError("VM '%s' not found" % vmname)
        else:
            server = filtered_servers[0]
            if not args.dryrun:
                server.delete()
    except novaclient.exceptions.ClientException, error:
        raise AiKillVmNovaError(error)
    except novaclient.exceptions.ConnectionRefused, error:
        raise AiKillVmNovaError(error)

    logging.debug("Delete request sent")

def delete_foreman_entry(hostname):
    """Deletes the FQDNized form of the passed hostname"""
    fqdn = socket.getfqdn(hostname)
    logging.debug("Deleting Foreman entry '%s'" % fqdn)
    url="https://%s:%u/api/hosts/%s" % \
        (args.foreman_hostname, args.foreman_port, fqdn)
    logging.debug("Issuing DELETE on %s" % url)
    headers = {'Content-type': 'application/json',
        'Accept': 'application/json, version=2',
        'User-Agent': 'ai-kill-vm'}
    logging.debug("With headers: %s" % headers)
    if not args.dryrun:
        try:
            response = requests.delete(url, timeout=args.foreman_timeout,
                headers=headers, auth=HTTPKerberosAuth(),
                verify=CERN_CA_BUNDLE, allow_redirects=True)
            if response.status_code == requests.codes.ok:
                logging.debug("Done")
            elif response.status_code == requests.codes.forbidden or \
                response.status_code == requests.codes.unauthorized:
                    raise AiKillVmForemanError("Authentication failed (expired or non-existent TGT?)")
            elif response.status_code == requests.codes.not_found:
                raise AiKillVmForemanError("Host not found in Foreman")
            elif response.status_code == requests.codes.internal_server_error:
                raise AiKillVmForemanError("Foreman's ISE. Open a bug against Foreman")
            else:
                raise AiKillVmForemanError("Uncontrolled status code (%s), please report a bug" %
                    response.status_code)
        except requests.exceptions.ConnectionError, error:
            raise AiKillVmForemanError("Connection error (%s)" % error)
        except requests.exceptions.Timeout, error:
            raise AiKillVmForemanError("Connection timeout")

def destroy_host(hostname):
    summary = {'hostname': hostname, 'success': False}
    try:
        delete_virtual_machine(hostname)
    except AiKillVmNovaError, error:
        summary['details'] = "Couldn't delete VM (%s). Foreman entry \
remains intact" % error
        return summary

    try:
        delete_foreman_entry(hostname)
    except AiKillVmForemanError, error:
        summary['details'] = str(error)
        return summary

    summary['success'] = True
    return summary

def main():
    """Application entrypoint"""
    global args
    args = parse_cmdline_args()
    configure_logging()

    try:
        verify_environment()
    except AiKillVmError, error:
        logging.error("Failed to validate user's environment (%s). Exiting..." % error)
        return 3

    try:
        verify_kerberos()
    except AiKillVmError, error:
        logging.error("TGT not found or expired. Exiting...")
        return 4

    format_output(map(destroy_host, args.hostname))

if __name__ == '__main__':
    sys.exit(main())
