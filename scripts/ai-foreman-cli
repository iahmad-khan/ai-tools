#! /usr/bin/perl -w

# To-do:

use strict;
use diagnostics;
use POSIX;
use Getopt::Long;
use Data::Dumper;
#use SOAP::Lite;# +trace => 'debug';
use SOAP::Lite + maptype => {};
use SOAP::Transport::HTTP;
use URI::Escape;
use LWP;
use JSON;
use Socket;
use NetAddr::IP;
use Date::Manip;
use Switch;
use DateTime;
use Text::TabularDisplay;
use YAML::Syck;
use MIME::Base64;

$Data::Dumper::Sortkeys = 1;

sub ForemanConfig($$);
sub LandbHostInfo(@);
sub ShowHost($@);
sub ShowConfig($);
sub DeleteHost($@);
sub ChkHost(@);
sub UpdateHost($@);
sub InstallHost(@);
sub SetupAims($$);
sub GetUserCredentials($);
sub HelpMessage(;$);
sub HandleOptions();
sub CheckAPIResponseStatus($);
sub CertMgrStageHostname($);
sub RogerModifyAlarms($$$);
sub SetBuild(@);

use Term::ANSIColor;
print color 'bold red';
print "All options but 'installhost' have been disabled.\n";
print "This CLI will disappear soon, please use the following instead:\n";
print "\t - ai-foreman: for CRUD operations (showhost, updatehost...)\n";
print "\t - ai-installhost: to prepare hosts for installation.\n";
print color 'reset';

HelpMessage("No arguments given.") if not @ARGV;

my $debug = my $verbose = my $dryrun = 0;
my %user_credentials = ();
my %foreman_conn_params = ( "hostname" => "judy.cern.ch",
                            "port" => 443,
                            "cookiejar" => undef);

my ($action,%opts) = HandleOptions();

#print "\@ARGV @ARGV\n";

#print Dumper(\%opts);#exit;

$verbose = 1 if $debug;

if ($foreman_conn_params{hostname} =~ m/judy(\.cern\.ch)?/i and $foreman_conn_params{port} == 443 and not defined $foreman_conn_params{cookiejar}) {
    print STDERR "[ERROR] Judy only accepts user cookies for authentication on the default port (use --foreman-cookiejar).\n";
    print STDERR "[INFO] Change the port to 9443 if you want to use your CERN login-passwd pair. See README.judy.\n";
    exit 1;
}

my @host = map {split(/,/,$_)} @ARGV;
if (not @host and not ($action eq "showhost" or $action eq "showconfig")){
    print STDERR "[ERROR] No hostname(s) given...\n";
    exit 1;
}

map {s/.cern.ch//; $_ = lc} @host;  # strip domain name, change to lower case

#
# Connect to Foreman
#
my $netlocation = "$foreman_conn_params{hostname}:$foreman_conn_params{port}";
my $url         = "https://$netlocation/api";
my $encurl      = "https://$netlocation";
my $realm       = "Application";
my $browser     = LWP::UserAgent->new;

#
# Get user credentials
#
if (not defined $foreman_conn_params{cookiejar}) {
    ($user_credentials{username},$user_credentials{password}) = GetUserCredentials($user_credentials{username});
    $browser->credentials($netlocation,$realm,$user_credentials{username} => $user_credentials{password});
    my $enccreds = encode_base64($user_credentials{username} . ':' . $user_credentials{password});
    $browser->default_header('Authorization' => 'Basic ' . $enccreds);
    $browser->max_redirect(1);
} else {
    use HTTP::Cookies::Netscape;
    my $cookie_jar = HTTP::Cookies::Netscape->new(
        file => "$foreman_conn_params{cookiejar}", ignore_discard => 1);
    print $cookie_jar->as_string() if $debug;
    $browser->cookie_jar( $cookie_jar );
    $browser->max_redirect(0);
    $user_credentials{username} ||= (getpwuid($<))[0];
}

# There's only one UserAgent shared by all the script, so we can
# set the headers we need only once.
#
# For GET requests, proper Accept
$browser->default_header('Accept' => "application/json");
# For POST, PUT and DELETE, proper Content-Type
$browser->default_header('Content-Type' => "application/json");
# See commit log for further details

my %fmdata = ();

if ($action eq "installhost"){
    InstallHost(\%opts,@host);
    exit 0;
}

#
# Do the user options have correct values?
#

my $err = 0;
for my $attr (qw(architecture model operatingsystem hostgroup environment domain ptable owner)){
    next if not defined $opts{$attr};
    my @values = sort grep {defined($_)} ($attr eq "owner" ? (values %{$fmdata{user}}, values %{$fmdata{usergroup}}) : values %{$fmdata{$attr}} );
    next if grep {$opts{$attr} eq $_} @values;
    my $table = Text::TabularDisplay->new();
    my $max = ($attr eq "hostgroup" ? 4 : 5);
    while (my @tmp = splice(@values,0,$max)){
        last if not @tmp;
	$tmp[0] = "  $tmp[0]";
	$table->add(@tmp);
    }
    my @txt = ("","Option \"--$attr\" has unknown value \"$opts{$attr}\". Valid values:","",split(/\n/,$table->render));
    map {print STDERR "[ERROR] $_\n"} @txt;
    $err++;
}
exit 1 if $err;

#
# Do the real work
#
if ($action eq "addhost" or $action eq "updatehost"){
    my @done = UpdateHost({%opts,("action" => $action)},@host);
    if (@done){
	print STDOUT "\n[INFO] Summary:\n\n";
	ShowHost(undef,@done);
	print STDOUT "\n";
    }
}

exit 0;

################################################################################################
#
# ShowHost(): display host information
#
sub ShowHost($@){
    my ($href,@host) = @_;
    my %opt = defined $href ? %$href : ();
    print STDOUT "[DEBUG] ".Dumper(\%opt,\@host) if $debug;
    if ($opt{all} or $opt{filter}){
	my $all_hosts_url = "${url}/hosts";
	if (defined $opt{filter}) {
	    print STDOUT "[INFO] Filter enabled, host list will be ignored.\n" if @host;
	    my $filter = uri_escape($opt{filter});
	    $all_hosts_url = "${all_hosts_url}?search=${filter}";
	    print STDOUT "[DEBUG] Query URI w/ filter applied: \"${all_hosts_url}\"\n" if $debug;
	}
	my $request = HTTP::Request->new("GET", $all_hosts_url."&per_page=10000000");
	my $response = $browser->request($request);
	if (not CheckAPIResponseStatus($response)) {
	    return -1;
	}
	my @hosts_from_api = sort map { $_->{'host'}->{'name'} } @{from_json($response->content)};
	@host = map {s/.cern.ch//; $_ = lc} @hosts_from_api;  # strip domain name, change to lower case
	print STDOUT "[INFO] Parsing information for ".scalar(@host)." machines - this may take a while...\n";
    }
    #print Dumper(\%opt); print "\@host = \"@host\"\n";
    #exit;

    #
    # Are the hosts known to Foreman?
    #
    my $table = Text::TabularDisplay->new(qw(Hostname LAS Hostgroup Environment OS Arch Model Ptable Comment));
    #my @out = ();
    for my $host (sort @host){
	my $request = HTTP::Request->new("GET","$url/hosts/$host" . ($host !~ /\./ ? ".cern.ch" : ""));
	my $response = $browser->request($request);
	next unless CheckAPIResponseStatus($response);
	print "[DEBUG] JSON: ".$response->content."\n" if $debug;
	my %data = %{from_json($response->content)};
	my $ownertype = lc($data{owner_type}); # values: "user", "usergroup"
	#print "\$ownertype = \"$ownertype\" \n".Dumper(\%{$fmdata{$ownertype}});
	#print Dumper(\%data);exit;
	#printf "%15s %-15s %15s %-15s %15s\n",$host,map {$data{$_} || "oops..."} qw(environment_id owner_id ip managed) if $debug;

	# make "Comment" field fit to print
	$data{comment} ||= "";
	$data{comment} =~ s/\n//g;
	$data{comment} =~ s/\s+/ /g;

	$data{operatingsystem} = $data{operatingsystem_name} || "";
	$data{architecture}    = $data{architecture_name} || "";
	$data{hostgroup}       = $data{hostgroup_name} || "";
	$data{environment}     = $data{environment_name} || "";
	$data{model}           = $data{model_name} || "";
	$data{ptable}          = $data{ptable_name} || "";

	# get information from the Node Classifier as well
	$request = HTTP::Request->new("GET","$encurl/node/$host.cern.ch?format=yml");
	$response = $browser->request($request);
	if (CheckAPIResponseStatus($response)){
	    print "[DEBUG] \"$url/node/$host?format=yml\": ".$response->content."\n" if $debug;
	    my $yaml = Load($response->content);
	    $data{alarmed} = $yaml->{parameters}->{alarmed};
	}else{
	    $data{alarmed} = "unkn";
	}
	#
	$table->add($host, map {$data{$_}} qw(alarmed hostgroup environment operatingsystem architecture model ptable comment));
    }

    if ($table->items){
	print $table->render . "\n";
	return 0;
    }else{
     	print STDERR "[ERROR] No machines found\n";
     	return -1;
    }

}

################################################################################################
#
# DeleteHost(): delete host
#
sub DeleteHost($@){
    my ($href,@host) = @_;
    my %opt = %$href;
    #
    # Are the hosts known to Foreman?
    #
    my @err = ();
    for my $host (sort @host){

	my $request = HTTP::Request->new("DELETE","$url/hosts/$host.cern.ch");
	my $response = $browser->request($request);
	if (not CheckAPIResponseStatus($response)) {
	    print STDERR "[ERROR] Could not delete host '$host' from Foreman.\n";
	    return 1;
	} else {
	    print STDOUT "Host '$host' deleted successfully.\n";
            RogerModifyAlarms($host, "false", "machine deleted via ai-foreman-cli");
	}
    }
    return 0;
}

################################################################################################
#
# ChkHost(): perform consistency checks 
#
sub ChkHost(@){
    my @host = @_;

    #
    # Are the hosts known to Foreman?
    #
    my @err = my %todo = ();
    for my $host (@host){
     	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
     	my $response = $browser->request($request);
	next unless CheckAPIResponseStatus($response);
	#
	my @error = ();
     	my %data = %{${from_json($response->content)}{host}};
	#print Dumper(\%data);exit;
	
	# IP address?
	my $iaddr = gethostbyname($host);
	die "aargh..." if not defined $iaddr;
	$iaddr = inet_ntoa($iaddr);
	push(@error,"$host: IP address in Foreman is $data{ip}, but DNS says $iaddr") if $data{ip} ne $iaddr;
	
	# IPMI ip-address?
	if (exists $data{sp_ip} and $data{sp_name}){
	    my $iaddr = gethostbyname($data{sp_name});
	    die "aargh..." if not defined $iaddr;
	    $iaddr = inet_ntoa($iaddr);
	    push(@error,"$data{sp_name}: IP address in Foreman is $data{sp_ip}, but DNS says $iaddr") if $data{sp_ip} ne $iaddr;
	}

	# print result
	if (@error){
	    map {print "[$host] $_\n"} @error;
	}else{
	    print "[$host] OK\n";
	}
    }
    return;
}

################################################################################################
#
# InstallHost(): generate kickstart files, call out to AIMS
#
sub InstallHost(@){
    my ($href,@host) = @_;
    my %opt = defined $href ? %$href : ();
    print STDOUT "[DEBUG] ".Dumper(\%opt,\@host) if $debug;


    #
    # Show the hosts
    #
    print STDOUT "[INFO] Installation requested for" . (scalar(@host) == 1 ? "" : " " .scalar(@host) ." machines" ) . ":\n\n";
    ShowHost($href,@host);
    print STDOUT "\n";

    #
    # Are the hosts known to Foreman?
    #
    my @err = my %todo = ();

    for my $host (@host){
     	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
     	my $response = $browser->request($request);
	push(@err,"Host \"$host\" unknown to Foreman") unless $response->is_success;
	next if @err;
	#
	# Sanity check: is the host known in DNS?
	#
     	my %data = %{from_json($response->content)};
	#print Dumper(\%data);exit;
	my $iaddr = gethostbyname($host);
	if (not defined $iaddr){
	    push(@err,"Cannot get IP address from DNS for host \"$host\"");
	    next;
	}
	$iaddr = inet_ntoa($iaddr);
	if ($data{ip} ne $iaddr){
	    push(@err,"IP-address differs between Foreman (\"$data{ip}\") and DNS (\"$iaddr\").");
	    next;
	}
	#
	# Sanity check: is the host registered as a "Managed Host" in Foreman?
	#
 	if (not $data{managed}){
	    push(@err,"Host \"$host\" is registered as \"unmanaged\" in Foreman");
	    next;
	}
	#
	# All's well, so let's store relevant information
	#
	$todo{$host}{operatingsystem} = $data{operatingsystem_name};
	$todo{$host}{architecture}    = $data{architecture_name};
	$todo{$host}{model}           = $data{model_name};
	$todo{$host}{hostname}        = $host;

	my ($owner_id,$owner_type) = ($data{owner_id},$data{owner_type});
	if ($owner_type eq "user"){
	    $todo{$host}{owner} = $fmdata{user}{$owner_id};
	}elsif ($owner_type eq "usergroup"){
	    $todo{$host}{owner} = $fmdata{usergroup}{$owner_id};
	}
	#print Dumper(\%fmdata);
     	#print Dumper(\%data);
	#print Dumper(\%todo);exit;
    }
    if (@err){
     	map {print STDERR "[ERROR] $_\n"} @err;
     	exit 1;
    }
    print STDOUT "[VERBOSE] Retrieved host information from Foreman\n" if $verbose;

    #
    # Prepare Kickstart file
    #
    for my $host (sort keys %todo){

	my %data = (USER => $user_credentials{username});

	if (gethostbyname("${host}-gigeth")){
	    print "[INFO] Getting LANdb info for host \"$host\", patience please...\n";
	    my %landb = LandbHostInfo($host);
	    #print Dumper(\%landb);exit

	    if (not %landb){
		print STDOUT "[WARN] Could not get Landb info for \$host\", skipping it...\n";
		next;
	    }
	    $data{NETWORK}  = "\n#\n# - onboot=yes for the 10GB interface, specify hostname";
	    $data{NETWORK} .= "\n# - onboot=no  for the  1GB interface, do *not* specify a hostname!\n#\n\n";
	    for my $name (sort keys %{$landb{$host}{Interfaces}}){
		my $mac = $landb{$host}{Interfaces}{$name}{HardwareAddress};
		if ($name eq $host){
		    $data{NETWORK} .= "network --bootproto=dhcp --device=$mac --onboot=yes --hostname $host.cern.ch\n";
		} elsif ($name eq "${host}-gigeth"){
		    $data{NETWORK} .= "network --bootproto=dhcp --device=$mac --onboot=no\n";
		}
	    }
	    #print $data{NETWORK};exit;
	    $todo{$host}{hostname} .= "-gigeth";
	#}else{
	#    $data{NETWORK} = "network --bootproto=dhcp --device=eth0 --hostname $host.cern.ch";
	#    $todo{$host}{hostname} = $host;
	}
	
	# my $model = $data{HWMODEL} = $todo{$host}{model};

	# if (uc($data{HWMODEL}) eq "HYPER-V VIRTUAL MACHINE" and $todo{$host}{operatingsystem} =~ /^(SLC|RedHat) 5\./){
	#     $data{FIRST_DRIVE} = "hda";
	# } else {
	#     $data{FIRST_DRIVE} = "sda";
	# }

	next if $todo{$host}{operatingsystem} =~ /^windows/i;

	# Get the KS file from Foreman
	my $iaddr = gethostbyname($host);
	die "aargh..." if not defined $iaddr;
	$iaddr = inet_ntoa($iaddr);
	my $ksfile = "$encurl/unattended/provision?spoof=$iaddr";
	my $request = HTTP::Request->new("GET",$ksfile);
	my $response = $browser->request($request);
	if (not $response->is_success){
	    print STDERR "[ERROR] Failed to retrieve a Kickstart file \"$ksfile\":\n";
	    print STDERR "[ERROR]   ".$response->content."\n";
	    #print STDERR Dumper($response)."AARGH! $url/unattended/provision?spoof=$iaddr\n";
	    exit;
	}
	my $template = $response->content;

	use Text::Template;
	my $tpl = new Text::Template(TYPE    => "STRING",
				     UNTAINT => 1,
				     SOURCE  => $template) or die "Couldn't construct template: $Text::Template::ERROR";

	my $result = $tpl->fill_in(HASH => \%data);
	if (not defined $result) {
	    print STDERR "Couldn't fill in template: $Text::Template::ERROR\n";
	    next;
	}
    
	$todo{$host}{ksfile} = POSIX::tmpnam();
	if (not open(F,"> $todo{$host}{ksfile}")){
	    print STDERR "[ERROR] Could not open \"$todo{$host}{ksfile}\" for writing: $!\n";
	    next;
	}
	print F $result;
	print $result if $debug;
	close F;
	
	my $enc_request = HTTP::Request->new("GET","$encurl/node/$host.cern.ch?format=yml");
	my $enc_response = $browser->request($enc_request);
	next unless CheckAPIResponseStatus($enc_response);
	use YAML::Syck;
	my $enc_data = Load($enc_response->content);
	if (exists $enc_data->{parameters}->{hwdbkopts} and $enc_data->{parameters}->{hwdbkopts} ne "none") {
	    $todo{$host}{hwdbkopts} = $enc_data->{parameters}->{hwdbkopts};
	}

    }
    #print Dumper(\%todo);exit;
    #
    for my $host (sort keys %todo){
	print STDOUT "[INFO] Calling certmgr-stage to stage host $host...\n";
	if (CertMgrStageHostname($host)) {
	    print STDERR "[ERROR] certmgr-stage didn't return zero exit code for host $host...\n";
	    exit 1;
	}
    }

    #
    # Upload to AIMS
    #
    @host = SetupAims(\%todo,$href);
    if (not @host){
	print STDERR "[ERROR] Upload to AIMS failed, exiting...\n";
	exit 1;
    }
     	
    if ($dryrun){
	print STDOUT "[INFO] Dryrun: build request for \"@host\" deliberately not submitted\n";
    }

    # Are machines enabled in LAS?
    my @alarmed = ();
    for my $host (@host){
	my $request = HTTP::Request->new("GET","$encurl/node/$host.cern.ch?format=yml");
	my $response = $browser->request($request);
	next unless CheckAPIResponseStatus($response);
	use YAML::Syck;
	my $yaml = Load($response->content);
	push(@alarmed,$host) if lc($yaml->{parameters}->{alarmed}) eq "true";
    }

    #my $mess1 = join("\n",map {"      ssh root\@punch puppetca --clean $_.cern.ch"} @host);
    my $mess2 = join("\n",map {"      ssh root\@$_ shutdown -r now"} @host);
    my $mess3 = "      ai-remote-power-control cycle ". join(",",@host)."\n";
    my $mess5 = "";
    if (@alarmed){
	map {$mess5 .= "[WARN] $_\n"} ("Note: alarms are active on:",(map {"    $_"} @host),"A reinstallation may trigger operator alarms.");
    }


    print <<EOMESS;

-- Reboot the host to start the installation:

$mess2

   or

$mess3

-- To see the progress of the installation please log into the console via Foreman.

$mess5

EOMESS

    return 0;
}
                                                            

################################################################################################
#
# SetBuild(): sets host for build
#

sub SetBuild(@){
    my @host = @_;
    for my $host (@host){
	my $request = HTTP::Request->new( "PUT", "$url/hosts/$host.cern.ch" );
	print "[DEBUG] JSON: " . to_json( { host => { "build" => 1 } } ) . "\n" if $debug;

	$request->content( to_json( { host => { "build" => 1 } } ) );
 	my $response = $browser->request($request);    

  if ( $response->is_success ) {
    print STDOUT "[INFO] Successfully built $host\n";
  }
  else {
    print STDERR "[ERROR] Cannot build \"$host\": "
    . $response->status_line . " :: "
    . $response->content . "\n";
  }
    }

    return 0;
}


################################################################################################
#
# UpdateHost(): update host information
#
sub UpdateHost($@){
    my ($href,@host) = @_;
    my %opt = %$href;
    print Dumper(\%opt) if $debug;

    my $action = $opt{action};
    delete $opt{action};
    if (not grep {$_ eq $action} qw(addhost updatehost)){
	print STDERR "[ERROR] UpdateHost: unsupported action \"$action\" specified\n";
	return undef;
    }

    #print "@host\n";

    #
    # get network data
    #
    my %landb = my %subnet = ();
    if ($opt{network}){
	%landb = LandbHostInfo(@host);
	print Dumper(\%landb) if $debug;
	for (@{from_json($browser->get("$url/subnets?format=json")->content)}){
	    my %tmp = %{$$_{subnet}};
	    %{$subnet{$tmp{id}}} = (network => $tmp{network}, mask => $tmp{mask});
	}
	#print Dumper(\%subnet);#exit;
    }

    #
    # installation media
    #
    if (defined $opt{operatingsystem} and not defined $opt{medium}){
	switch ($opt{operatingsystem}) {
	    case /^SLC/      { $opt{medium} = "SLC"           }
	    case /^CentOS/   { $opt{medium} = "CentOS Mirror" }
	    case /^RedHat 6/ { $opt{medium} = "RedHat"        }
	    case /^Fedora/   { $opt{medium} = "Fedora Mirror" }
	}
	if (not defined $opt{medium}){
	    print STDERR "[ERROR] UpdateHost: no medium defined for operating system \"$opt{operatingsystem}\"\n";
	    return undef;
	}
    }
    print Dumper(\%opt) if $debug;
  
    #
    # build the data structure to be sent to Foreman
    #
    my %data = my @err = ();

    for my $attr (keys %opt){
	for (keys %{$fmdata{$attr}}){
	    if (lc(${$fmdata{$attr}}{$_}) eq lc($opt{$attr})){
		$data{"${attr}_id"} = $_;
		last;
	    }
	}
	push(@err,"Could not find Foreman identifier for attribute \"$attr\" with requested value \"$opt{$attr}\"") if not exists $data{"${attr}_id"} and %{$fmdata{$attr}};
    }
    if (@err){
	map {print STDERR "[ERROR] $_\n"} sort @err;
	return undef;
    }
    
    # comment (if any)
    $data{comment} = exists $opt{comment} ? $opt{comment} : undef;

    # set the ownership information
    if (exists $opt{owner}){
	if (grep {$opt{owner} eq $_} values %{$fmdata{user}}){
	    $data{owner_type} = "User";
	}elsif (grep {$opt{owner} eq $_} values %{$fmdata{usergroup}}){
	    $data{owner_type} = "Usergroup";
	}else{
	    print STDERR "[ERROR][BUG] Unsupported ownertype detected, exiting\n";
	    exit 1;
	}
	for my $id (keys %{$fmdata{lc($data{owner_type})}}){
	    if (${fmdata{lc($data{owner_type})}}{$id} eq $opts{owner}){
		$data{owner_id} = $id;
		last;
	    }
	}
    }

    #
    #
    #
#    print Dumper(\%fmdata) if $debug;#exit;
    my @done = ();
    for my $host (sort @host){
	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
	my $response = $browser->request($request);
	if ($action eq "addhost" and $response->is_success){ # adding a host that already exists?
	    if ($opt{reset}){
		$request = HTTP::Request->new("DELETE","$url/hosts/$host.cern.ch");
		$response = $browser->request($request);
		if (not CheckAPIResponseStatus($response)) {
		    print STDERR "[ERROR] Could not delete host \"$host\" from Foreman.\n";
		    next;
		}
	    }else{
		print STDOUT "[WARN] Ignoring existing host \"$host\".\n";
		next;
	    }
	}elsif ($action eq "updatehost" and not $response->is_success){
	    print STDOUT "[WARN] Ignoring non-existent host \"$host\".\n";
	    next;
	}
	print STDOUT "[VERB] " . ($action eq "addhost" ? "Adding" : "Updating") . " \"$host\"\n" if $verbose;

	#
	# Network info
	#
	if ($opt{network}){
	    my %network = ();
	    map {delete @data{($_,"sp_$_")}} qw(name mac ip subnet_id); # clean up %data a bit
	    for my $interface (keys %{$landb{$host}{Interfaces}}){
		next unless ($interface eq $host);
		my $ipaddr = $landb{$host}{Interfaces}{$interface}{IPAddress};
		my $subnet_id = undef;
		my $ip = NetAddr::IP->new($ipaddr);
		for my $id (keys %subnet){
		    if ($ip->within(NetAddr::IP->new($subnet{$id}{network},$subnet{$id}{mask}))){
			$subnet_id = $id;
			last;
		    }
		}
		if (not defined $subnet_id){
		    print STDERR "[ERROR] Could not get subnet_id for host $interface, exiting!\n";
		    exit 1;
		}

		my $prefix = $interface eq $host ? "" : "sp_"; # Ordinary interface, or IPMI?
		$network{$prefix . "name"}      = $interface;
		$network{$prefix . "mac"}       = $landb{$host}{Interfaces}{$interface}{HardwareAddress};
		$network{$prefix . "ip"}        = $ipaddr;
		$network{$prefix . "subnet_id"} = $subnet_id;
	    }
	    %data = (%data, %network);
	}

	#
	# Sanity checks
	#
        map {delete $data{$_} if not defined $data{$_}} keys %data;
	if (not %data and $action eq "updatehost"){
	    print STDERR "[ERROR] Nothing to update?!\n";
	    last;
	}
	print Dumper(\%data) if $debug;#exit;

	if ($opt{network} and not exists $data{name}){
	    print STDERR "[ERROR] Incomplete network information for host \"$host\", skipping it...\n";
	    next;
	}

	#
	# Action!
	#
     	$request = HTTP::Request->new($action eq "updatehost" ? ("PUT","$url/hosts/$host.cern.ch") : ("POST","$url/hosts") );
	print "[DEBUG] JSON: ".to_json({host => \%data})."\n" if $debug;
     	$request->content(to_json({host => \%data}));
	
     	$response = $browser->request($request);
	
     	if ($response->is_success){
	    print STDOUT "[INFO] Successfully " . ( $action eq "addhost" ? "added" : "updated" ) . " $host\n";
	    push(@done,$host);
            if ($action eq "addhost") {
                RogerModifyAlarms($host, "false", "Host installed / added via ai-foreman-cli");
            }
	}else{
     	    print STDERR "[ERROR] Cannot " . ( $action eq "addhost" ? "add" : "update" ) . " \"$host\": " . $response->status_line . " :: " . $response->content ."\n";
     	}
    }

    return @done;
}

################################################################################################
#
# ForemanConfig(): retrieve Foreman configuration information
#
sub ForemanConfig($$){
    my ($browser,$url) = @_;
    my %config = ();

    # record ptable per OS
    my %ptable = my %medium = ();
    my $response = $browser->get("$url/operatingsystems?format=json&per_page=10000000");
    return %config unless CheckAPIResponseStatus($response);
    # TODO: responses should be checked in all subsequent requests
    for (@{from_json($response->content)}){
	my %data = %{$$_{operatingsystem}};
	#print Dumper(\%data);#exit;
	for (@{$data{ptables}}){
	    my %pt = %{$$_{ptable}};
	    my $name = $pt{name};
	    $ptable{$name}++;
	}
	for (@{$data{media}}){
	    my %med = %{$$_{medium}};
	    my $name = $med{name};
	    $medium{$name}++;
	}
    }
    #print Dumper(\%medium);exit;
    my @hgp = @{from_json($browser->get("$url/hostgroups?format=json&per_page=10000000")->content)};
    my %hgp = ();
    for (@hgp){
	my %dum = %$_;
	my $id       = $dum{hostgroup}{id};
	$hgp{$id}{ancestry} = $dum{hostgroup}{ancestry};
	$hgp{$id}{name}     = $dum{hostgroup}{name};
    }
    for my $id (keys %hgp){
	my $name = $hgp{$id}{name};
	my $path = $hgp{$id}{ancestry};
	if (defined $path){
	    my @path = split(/\//,$path);
	    $name = join("/" ,map {$hgp{$_}{name}} @path) . "/$name";
	}
	$config{hostgroup}{$id} = $name;
    }
    #exit;

    # partition tables
    map {$config{ptable}         {$$_{ptable}         {id}} = $$_{ptable}         {name} } @{from_json($browser->get("$url/ptables?format=json&per_page=10000000")->content)};
    map {delete $config{ptable}{$_} unless exists $ptable{$config{ptable}{$_}}} keys %{$config{ptable}}; # remove ptables that are supported for unsupported OS-es :)

    # installation media
    map {$config{medium}         {$$_{medium}         {id}} = $$_{medium}         {name} } @{from_json($browser->get("$url/media?format=json&per_page=10000000")->content)};
    map {delete $config{medium}{$_} unless exists $medium{$config{medium}{$_}}} keys %{$config{medium}}; # remove media that are supported for unsupported OS-es :)

    map {$config{operatingsystem}{$$_{operatingsystem}{id}} = $$_{operatingsystem}{name}." ".$$_{operatingsystem}{major}.".".$$_{operatingsystem}{minor} } @{from_json($browser->get("$url/operatingsystems?format=json&per_page=10000000")->content)};
    map {$config{architecture}   {$$_{architecture}   {id}} = $$_{architecture}   {name} } @{from_json($browser->get("$url/architectures?format=json&per_page=10000000")->content)};
    map {$config{model}          {$$_{model}          {id}} = $$_{model}          {name} } @{from_json($browser->get("$url/models?format=json&per_page=10000000")->content)};
    map {$config{environment}    {$$_{environment}    {id}} = $$_{environment}    {name} } @{from_json($browser->get("$url/environments?format=json&per_page=10000000")->content)};
    map {$config{user}           {$$_{user}           {id}} = $$_{user}           {login}} @{from_json($browser->get("$url/users?format=json&per_page=10000000")->content)};
    map {$config{usergroup}      {$$_{usergroup}      {id}} = $$_{usergroup}      {name} } @{from_json($browser->get("$url/usergroups?format=json&per_page=10000000")->content)};
    map {$config{domain}         {$$_{domain}         {id}} = $$_{domain}         {name} } @{from_json($browser->get("$url/domains?format=json&per_page=10000000")->content)};
    #map {$config{subnet}         {$$_{subnet}         {id}} = $$_{subnet}         {name} } @{from_json($browser->get("$url/subnets?format=json")->content)};
    #%{$config{sp_subnet}} = %{$config{subnet}};

    #print Dumper(\@{from_json($browser->get("$url/usergroups?format=json")->content)});exit;
    #print Dumper(\%config);exit;
    return %config;
}

################################################################################################
#
# LandbHostInfo(): retrieve {mac,ip} information for each interface from LANdb
#
sub LandbHostInfo(@){
    my @device = @_;

    if (not defined $user_credentials{password}) {
      ($user_credentials{username},$user_credentials{password}) = GetUserCredentials($user_credentials{username});
    }
    my $client = SOAP::Lite
	->uri('http://network.cern.ch/NetworkService')
	->xmlschema('http://www.w3.org/2001/XMLSchema')
	->proxy('https://network.cern.ch/sc/soap/soap.fcgi?v=4', keep_alive=>1);

    # Get Auth token
    my $call = $client->getAuthToken($user_credentials{username},$user_credentials{password},'NICE');
    
    my ($auth) = $call->result;
    if ($call->fault){
        print STDERR "ERROR: failed to authenticate to LANdb.\n";
        exit 1;
    }

    my $authHeader = SOAP::Header->name('Auth' => { "token" => $auth });

    my %landb = ();
    for my $device (@device){
	$call = $client->getDeviceInfo($authHeader,$device);
	
	my $bu = $call->result;
	if ($call->fault) {
	    print STDOUT "[WARN] Device \"$device\" not found in Landb, ignoring it...\n";
	    next;
	}
	#print Dumper($bu);#exit;

	#
	# First, store information for all interfaces with bound NICs
        #
	for (@{$bu->{Interfaces}}) {
	    #print Dumper(\$_);
	    my $HardwareAddress = $_->{BoundInterfaceCard}->{HardwareAddress};
	    if (defined $HardwareAddress){
		$HardwareAddress =~ s/\-/:/g;
		my $Name = lc($_->{Name});
		my $IPAddress = $_->{IPAddress};
		%{$landb{$device}{Interfaces}{$Name}} = (HardwareAddress => $HardwareAddress, IPAddress => $IPAddress);
	    }
	}

        #
        # Not all machines are properly registered. In many cases, the "main" interface (the one with the same name as the device
        # does not have a bound NIC. In these cases, we use the "lowest" non-bound MAC address found
        #
	my $Name = lc($bu->{DeviceName});
	if (not exists $landb{$device}{Interfaces}{$Name}){
	    # get sorted list MAC addresses of all bound interfaces
	    my @bound_mac = sort grep {$_ if defined $_} map {$_->{BoundInterfaceCard}->{HardwareAddress} if defined $_->{BoundInterfaceCard}} @{$bu->{Interfaces}};
	    #print "\@bound_mac = ".Dumper(\@bound_mac);
	    for my $mac (sort map {$_->{HardwareAddress}} @{$bu->{NetworkInterfaceCards}}) {
		next if grep {$mac eq $_} @bound_mac; # ignore if already bound (for example, to IPMI interface)
		$mac =~ s/\-/:/g;
		${$landb{$device}{Interfaces}{$Name}}{HardwareAddress} = $mac;
		last;
	    }
	    for (@{$bu->{Interfaces}}) {
		if ($Name eq lc($_->{Name})){
		    ${$landb{$device}{Interfaces}{$Name}}{IPAddress} = $_->{IPAddress};
		}
	    }
	}
    }

    #print Dumper(\%landb);
    #exit;

    return %landb;
}

################################################################################################
#
# SetupAims(): upload Kickstart file to AIMS, and configure it
#
sub SetupAims($$){
    my $href = shift @_;
    my %todo = %$href;
    $href = shift @_;
    my %opts = %$href;
    #print Dumper(\%todo);exit;
    my $ksopts = '';
    if($opts{ksopts}) {
      $ksopts = $opts{ksopts};
    }

    # Run "aims2 showimg all" to get list of all available AIMS images
    my %AimsImg = (
	# CC
        "CentOS 7.1"  => "CC71",
        "CentOS 7.2"  => "CC72",
	# SLC
        "SLC 6.8"     => "SLC68",
        "SLC 6.7"     => "SLC67",
        "SLC 6.6"     => "SLC66",
        "SLC 6.5"     => "SLC65",
        "SLC 6.4"     => "SLC64",
        "SLC 6.3"     => "SLC63",
	"SLC 6.2"     => "SLC62",
	"SLC 6.1"     => "SLC61_BETA",
        #"SLC 6"       => "SLC6X",
        "SLC 5.11"     => "SLC511",
        "SLC 5.10"     => "SLC510",
        "SLC 5.9"     => "SLC59",
        "SLC 5.8"     => "SLC58",
        "SLC 5.7"     => "SLC57",
	# RedHat
        "RedHat 7.2"  => "RHEL_7_2",
        "RedHat 7.1"  => "RHEL_7_1",
        "RedHat 6.8"  => "RHEL_6_8",
        "RedHat 6.7"  => "RHEL_6_7",
        "RedHat 6.6"  => "RHEL_6_6",
        "RedHat 6.5"  => "RHEL_6_5",
        "RedHat 6.4"  => "RHEL_6_4",
        "RedHat 6.3"  => "RHEL_6_3",
        "RedHat 6.2"  => "RHEL_6_2",
        "RedHat 6.1"  => "RHEL_6_1",
        "RedHat 5.11"  => "RHEL_5_11",
        "RedHat 5.10"  => "RHEL_5_10",
        "RedHat 5.9"  => "RHEL_5_9",
        "RedHat 5.8"  => "RHEL_5_8",
        "RedHat 5.7"  => "RHEL_5_7",
	# Fedora
	"Fedora 19"   => "FEDORA19",
	"Fedora 18"   => "FEDORA18",
	"Fedora 17"   => "FEDORA17",
	"Fedora 16"   => "FEDORA16",
	"Fedora 15"   => "FEDORA15",
	# Windows
	"windows 6.2" => "DIANE",
        );
    
    #
    # Reshuffle input data
    #
    #print Dumper(\%todo);
    for my $oldname (keys %todo){
	my $newname = $todo{$oldname}{hostname};
	if ($newname ne $oldname){
	    %{$todo{$newname}} = %{$todo{$oldname}};
	    $todo{$newname}{hostname} = $oldname;
	    delete $todo{$oldname};
	}
    }
    #print Dumper(\%todo);exit;

    #
    # Upload the kickstart files
    #
    for my $host (sort keys %todo){
	my $cnt = 0;
	my @kopts = qw(text network ks ksdevice=bootif latefcload);
	push(@kopts, split(/ +/, $ksopts));
	#my $kopts = "text network ks ksdevice=bootif latefcload $ksopts";
	#$kopts .= " pcie_aspm=off" if $model eq "X8DT6";
	# Add kopts coming from HWDB
	if (exists $todo{$host}{hwdbkopts}) {
	    push(@kopts, split(/ +/, $todo{$host}{hwdbkopts}));
	}
	push(@kopts, "nodmraid"); # AI 738, SNOW INC147316
	my $kopts = join(' ', @kopts);
	my $model = lc($todo{$host}{model});

	print STDOUT "[VERB] kopts = $kopts\n" if $verbose;

	# Console options
	use Switch;
	switch ($model) {
	    case "hyper-v virtual machine" { $kopts .= ""                                   }
	    case "x8dt6"                   { $kopts .= " console=tty0 console=ttyS2,9600n8" }
	    else                           { $kopts .= " console=tty0" }
	}
	if (not exists $AimsImg{$todo{$host}{operatingsystem}}){
	    print STDERR "[ERROR] No suitable AIMS target for Operating System \"$todo{$host}{operatingsystem}\" available. Probably a bug in the script you are running :)\n";
	    exit 1;
	}
	$todo{$host}{aimstarget} = $AimsImg{$todo{$host}{operatingsystem}} . "_" . uc($todo{$host}{architecture});
	if ($todo{$host}{operatingsystem} !~ /^windows/i){
	    $todo{$host}{aimscmd}    = "/usr/bin/aims2client addhost --hostname $host --pxe --name $todo{$host}{aimstarget} --kickstart $todo{$host}{ksfile} --kopts \"$kopts\" ";
	}else{
	    $todo{$host}{aimscmd}    = "/usr/bin/aims2client addhost --hostname $host --pxe --name $todo{$host}{aimstarget}";
	}

	if ($dryrun){
	    print STDOUT "[DRYRUN] Deliberately *not* configuring AIMS for $host\n";
	    next;
	}

	print STDOUT "[INFO] Configuring AIMS for $host: $todo{$host}{aimscmd}\n";
	if (system("$todo{$host}{aimscmd} 2>/dev/null 1>/dev/null") != 0){
	    print STDERR "[ERROR] AIMS configuration failed: $!\n";
	}
    }

    if ($dryrun){
	map {unlink $todo{$_}{ksfile}} keys %todo unless $debug;
	return (sort keys %todo);
    }

    #
    # Verify AIMS status
    #
    my $cnt = 0;
    my @done = ();
    while (1){
	#print "\$cnt = $cnt\n";
	#print Dumper(\%todo);
	print "[INFO] Verifying that AIMS is properly set up, patience please...\n";
	sleep 5;

	#
	# get status information
	#
	my $aims = "/usr/bin/aims2client showhost --full " . join(",",sort keys %todo);
	print "[VERB] Running \"$aims\"\n" if $verbose;
	open(AIMS,"$aims |") or die "aargh...";
	my $hostname = undef;
	my %status = ();
	while(<AIMS>){
	    chomp;
	    if (/^\s*Hostname:\s+(\S+)/){
		$hostname = lc($1);
	    }elsif (/^\s*PXE status:\s+(\S+)/){
		$status{$hostname}{pxestatus} = $1 if defined $hostname;
	    }elsif (/^\s*PXE boot synced:\s+(\S+)/){
		$status{$hostname}{syncstatus} = $1 if defined $hostname;
	    }
	}
	close AIMS;
	if ($debug){
	    map {printf "[DEBUG] %20s - PXE status = %3s - SYNC status = %3s\n",$_,($status{$_}{pxestatus} || "???"),($status{$_}{syncstatus} || "???")} sort keys %todo;
	}

	#
	# check if all is well
	#
	for my $hostname (sort keys %todo){
	    if (not exists $status{$hostname}){
		print STDOUT "[WARN] AIMS did nothing for host \"$hostname\". Re-uploading with \"$todo{$hostname}{aimscmd}\"\n";
		system("$todo{$hostname}{aimscmd}");
	    }elsif ($status{$hostname}{pxestatus} eq "OFF"){
		print STDOUT "[WARN] PXE status \"OFF\" for host \"$hostname\". Executing \"/usr/bin/aims2client pxeon $hostname $todo{$hostname}{aimstarget}\"\n";
		system("/usr/bin/aims2client pxeon $hostname $todo{$hostname}{aimstarget} 2>/dev/null 1>/dev/null");
		$cnt = 0;
	    }elsif ($status{$hostname}{syncstatus} ne "Y"){
		print STDOUT "[VERB] Sync status \"$status{$hostname}{syncstatus}\" for host \"$hostname\" -> Be patient...\n" if $verbose;
	    }else{
		print STDOUT "[INFO] Host \"$hostname\" is properly configured in AIMS\n";
		unlink $todo{$hostname}{ksfile} if (not $debug and defined $todo{$hostname}{ksfile});
		push(@done,$todo{$hostname}{hostname});
		delete $todo{$hostname};
	    }
	}
	#
	# anything left to do?
	#
	last if not %todo; 
	if (++$cnt == 12){
	    my @host = sort keys %todo;
	    my $dum = scalar(@host) == 1 ? "Machine \"@host\"" : "Machines \"".join("\", \"",@host)."\"";
	    print STDERR "[ERROR] $dum still not properly configured in AIMS, giving up...\n";
	    last;
	}
	print "[DEBUG] Loop again \$cnt = $cnt\n" if $debug;
    }

    if (@done){
	@done = sort @done;
	print STDOUT "\n[INFO] AIMS status for successfully configured hosts:\n[INFO]\n";
	open(AIMS, "/usr/bin/aims2client showhost ".join(",",map { gethostbyname($_ . "-gigeth") ? $_ . "-gigeth" : $_ } @done)." |");
	while (<AIMS>){
	    print STDOUT "[INFO]   $_";
	}
	close AIMS;
    }
    
    return @done;
}

################################################################################################
#
# ShowConfig(): display configuration information
#
sub ShowConfig($){
    my $href = shift @_;
    my %config = %$href;

    my $table = Text::TabularDisplay->new();

    for my $attr (sort keys %config){
	my @values = sort values %{$config{$attr}};
	$table->add(uc($attr));
	while (my @tmp = splice(@values,0,5)){
	    last if not @tmp;
	    $tmp[0] = "  $tmp[0]";
	    $table->add(@tmp);
	}
    }
    print $table->render . "\n";

    return 0;
}

################################################################################################
#
# HandleOptions(): parse user options
#
sub HandleOptions(){

    $action = shift @ARGV;

    my %options = (
		   installhost => [qw(ksopts=s)],
    );
    HelpMessage("Mandatory parameter [".join("|",sort keys %options)."] missing") unless exists $options{$action};

    my %opts = (debug   => \$debug,
		dryrun  => \$dryrun,
		verbose => \$verbose);
 
    my $rc = Getopt::Long::GetOptions(\%opts,
				      (map {$_ => \$opts{(split(/=/,$_))[0]}} @{$options{$action}}),
				      "debug","dryrun","verbose",
				      "cern-user=s"         => \$user_credentials{username},
				      "foreman-host=s"      => \$foreman_conn_params{hostname},
				      "foreman-port=i"      => \$foreman_conn_params{port},
				      "foreman-cookiejar=s" => \$foreman_conn_params{cookiejar},
	);
    HelpMessage("Could not parse options.") if not $rc;
    $verbose = 1 if $debug;
    map {delete $opts{$_} unless defined $opts{$_}} keys %opts;

    if ($action eq "addhost"){
        my @err = ();
	map {push(@err,$_) unless exists $opts{$_}} qw(operatingsystem architecture hostgroup ptable owner);
	if (@err){
	    map {print STDERR "[ERROR] Action \"$action\" requires mandatory option \"$_\"\n"} @err;
	    exit 1;
	}
	$opts{model}       ||= "undefined";
	$opts{domain}      ||= "cern.ch";
	$opts{environment} ||= "production";
	$opts{network}       = 1;
    }elsif ($action eq "updatehost"){
	#$opts{medium} = $opts{operatingsystem};
	#print Dumper(\%opts);
	map {delete $opts{$_} unless defined $opts{$_}} keys %opts;
	#print Dumper(\%opts);exit;

	my $cnt = 0;
	my @opt = qw(operatingsystem architecture hostgroup model owner ptable comment network environment);
	map {$cnt++ if defined $opts{$_}} @opt;
	if ($cnt == 0){
	    print STDERR "[ERROR] Action \"$action\" requires at least one of the options \"--". join("\", \"--",@opt)."\"\n";
	    exit 1;
	}
    }elsif ($action eq "disownhost"){  # "disownhost" is a special case of "updatehost"
	$action = "updatehost";
	$opts{operatingsystem} ||= "SLC 6.5";
	$opts{architecture}    ||= "x86_64";
	$opts{hostgroup}       ||= "disowned";
	#$opts{model}           ||= "";
	$opts{owner}           ||= "CC-Sysadmins";
	$opts{ptable}          ||= "RedHat default";
	$opts{comment}         ||= "disowned by $user_credentials{username} ".strftime("(%b %d, %Y)",localtime(time));
	$opts{domain}          ||= "cern.ch";
	$opts{environment}     ||= "production";
	$opts{network}           = 1;
    }elsif ($action eq "showhost"){
	if (not @ARGV and not $opts{all} and not $opts{filter}){
	    print STDERR "[ERROR] Action \"$action\" requires options \"--all\", \"--filter\" or a list of hostnames.\n";
	    exit 1;
	}
	if ($opts{all} and $opts{filter}) {
	    print STDERR "[ERROR] Options \"--all\" and \"--filter\" are mutually exclusive.\n";
	    exit 1;
	}
    }
				      
    return $action,%opts;
}

################################################################################################
#
# GetUserCredentials(): return username/password combination of the cern-account to be used
#                       in subsequent calls to Landb etc.
#

sub GetUserCredentials($){

    use Net::Netrc;
    use Term::ReadKey;

    my $username = shift @_;
    my $password = undef;

    my $mach = undef;
    if (defined $username){
	$mach = Net::Netrc->lookup("network.cern.ch",$username);
    }

    if ($mach){
	$password = $mach->password;
    }else{
	if (not defined $username){
	    print STDOUT "Please give the CERN username/password combination: \n";
	    print STDOUT "   - username : ";
	    chomp($username = <STDIN>);
	    if (not defined $username){
		print STDERR "Failed to read a username, exiting\n";
		return ();
	    }
	}else{
	    print STDOUT "Please give the password for CERN account \"$username\": \n";
	}
	print STDOUT "   - password : ";
	ReadMode("noecho",);
	chomp($password = <STDIN>);
	ReadMode("normal");
	print "\n";
	if (not defined $password){
	    print STDERR "failed to read a password, exiting\n";
	    return ();
	}
    }

    return ($username,$password);
}

################################################################################################
#
# HelpMessage(): displays user help
#

sub HelpMessage(;$){
    map {print STDOUT "$_\n"} @_;
    use File::Basename;
    print STDOUT"\nRun \"man ".basename $0."\" for more information.\n";
    #use Pod::Usage;
    #pod2usage(-verbose=> 2);
    exit 0;

}

################################################################################################
#
# CheckAPIResponseStatus(): Checks if authentication failed and informs
# the user about the outcome.
#
sub CheckAPIResponseStatus($) {
    my $response = shift;
    # Good response codes (2xx)
    return 1 if $response->is_success;

    # Redirects (3xx)
    # mod_shib returns 302 with location set (login.cern.ch) if
    # provided creds are invalid.
    if ($response->code() == HTTP::Status::HTTP_FOUND &&
	$response->header('Location') =~ /login\.cern\.ch/ ) {
	print STDERR "[ERROR] Bad cookie, unable to login.\n";
	return 0;
    }
    # Errors (4xx)
    if ($response->code() == HTTP::Status::HTTP_UNAUTHORIZED ||
        $response->code() == HTTP::Status::HTTP_FORBIDDEN) {
	print STDERR "[ERROR] Bad credentials or not enough access level.\n";
    } elsif ($response->code() == HTTP::Status::HTTP_NOT_FOUND ) {
	print STDERR "[ERROR] Resource not found (Foreman said 404)\n";
    } else {
	my $message = $response->message();
	print STDERR "[ERROR] Request failed ($message)\n";
    }
    return 0;
}

################################################################################################
#
# CertMgrStageHostname(): Stages a given hostname using certmgr-stage
#
sub CertMgrStageHostname($) {
    my $hostname = shift;
    my $cmdline = "/usr/bin/certmgr-stage --host $hostname.cern.ch";
    $cmdline .= " --debug" if $debug;
    print STDOUT "[DEBUG] Will execute \"$cmdline\"\n" if $debug;
    if ($dryrun){
	print STDOUT "[DRYRUN] Host staging deliberately not executed\n";
	return 0;
    }

    return system($cmdline);
}

################################################################################################
##
## RogerModifyAlarms(): switch alarms on or off for given host with optional message
#
sub RogerModifyAlarms($$$) {
    my ($hostname, $alarm_state, $msg) = @_;
    if (($alarm_state ne "true") && ($alarm_state ne "false")) {
        print STDERR "[ERROR] Received request to set roger --alarm_state to '$alarm_state' which is invalid\n";
        return 1;
    }
    my $cmdline = "/usr/bin/roger update $hostname --all_alarms $alarm_state";
    $cmdline .= " --message '$msg'" if $msg;
    if ($dryrun) {
        print STDOUT "[DRYRUN] so not executing '$cmdline'\n";
        return 0;
    }
    print STDOUT "[DEBUG] modifying roger alarms for '$hostname' to '$alarm_state'\n";
    return system($cmdline);
}

__END__

=pod

=head1 NAME

ai-foreman-cli - Utility to prepare hosts for installation.

=head1 DESCRIPTION

ai-foreman-cli is a command line interface to the Foreman setup of the Agile Infrastructure project.

=head1 SYNOPSIS

B<ai-foreman-cli> [--help]

B<ai-foreman-cli> I<ACTION> I<[OPTIONS]> I<[HOSTNAME]>

=head1 ACTIONS

=over 4

=item B<installhost> [OPTIONS] HOSTNAME ...

Gets kickstart files from Foreman, uploads them to AIMS and enables the host for installation.

=item B<help>

Display this help

=back

=head1 OPTIONS

Action specific options

=over 4

=item B<installhost>

=over 8

=item B<--ksopts> STRING

Optional arguments that will be passed to Kickstart/Anaconda, in addition to those picked by this tool.

Examples: --ksopts "nousb nousbstorage" 

=back

=back

General options

=over 4

=item B<--help>

Shows this help description

=item B<--verbose>

Be verbose

=item B<--debug>

Print debug output

=item B<--dryrun>

For the installhost action: do not upload to AIMS

=back

All options can be abbreviated to shortest distinctive length. Single minus preceding option name may be used instead of double one.

=head1 EXAMPLES

ai-foreman-cli installhost janvm01.cern.ch --foreman-port 9443

=head1 AUTHOR

Jan van Eldik <Jan.van.Eldik@cern.ch>

=head1 KNOWN BUGS

=cut
