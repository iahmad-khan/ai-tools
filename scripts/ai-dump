#!/usr/bin/python

try:
    import simplejson as json
except ImportError:
    import json
import yaml
import os
import sys
import urllib2
import iso8601
import datetime
import pytz
import humanize
import teigi.rogerclient
import prettytable
import argcomplete

from argparse import ArgumentParser
from aitools.common import fqdnify
from aitools.common import add_common_puppetdb_args
from aitools.common import add_common_foreman_args
from urllib2_kerberos import HTTPKerberosAuthHandler
from aitools.completer import ForemanCompleter

from ConfigParser import SafeConfigParser

def do_request(server, port, endpoint, show_url=False, data=False):
    url = "https://%s:%s/%s" % (server, port, endpoint)
    if show_url:
        print url
    opener = urllib2.build_opener()
    opener.add_handler(HTTPKerberosAuthHandler())
    if data:
        headers = {"Content-type": "application/json"}
    else:
        headers = {"Accept": "application/json"}
    request = urllib2.Request(url, headers=headers)
    try:
        resp = opener.open(request)
        resp = resp.read()
    except urllib2.HTTPError, e:
        # python 2.4 is dumb
        if e.code >= 200 and e.code < 300:
            # it's a success you ninny
            resp = e.read()
        else:
            if e.code == 404:
                # we're expecting things to be missing
                return None
            sys.stderr.write("Error: failed to open '%s': '%s'" % (url, e))
            return None
    except urllib2.URLError, e:
        sys.stderr.write("Error: failed to open '%s': '%s'" % (url, e))
        return None

    j = json.loads(resp)
    return j

def do_request_yaml(server, port, endpoint, show_url=False, data=False):
    url = "https://%s:%s/%s" % (server, port, endpoint)
    if show_url:
        print url
    opener = urllib2.build_opener()
    opener.add_handler(HTTPKerberosAuthHandler())
    if data:
        headers = {"Content-type": "application/yaml"}
    else:
        headers = {"Accept": "application/yaml"}
    request = urllib2.Request(url, headers=headers)
    try:
        resp = opener.open(request)
        resp = resp.read()
    except urllib2.HTTPError, e:
        # python 2.4 is dumb
        if e.code >= 200 and e.code < 300:
            # it's a success you ninny
            resp = e.read()
        else:
            if e.code == 404:
                # we're expecting things to be missing
                return None
            sys.stderr.write("Error: failed to open '%s': '%s'" % (url, e))
            return None
    except urllib2.URLError, e:
        sys.stderr.write("Error: failed to open '%s': '%s'" % (url, e))
        return None

    y = yaml.load(resp)
    return y

def location_name(lan_dblocation):
    room = lan_dblocation.split(' ')[0]
    if room == '0513':
        return "(Meyrin CC)"
    elif room == '0613':
        return "(Wigner CC)"
    elif room == 'XXX':
        return '(???)'
    else:
        return ""

def get_roger_client(pargs, host):
    config = SafeConfigParser()
    server = None
    port = None
    confloc = "/etc/roger.conf" #TODO: pargs.configfile
    use_kerberos = True
    if not confloc:
        confloc = os.environ.get("ROGERCONF", "/etc/roger.conf")
    if confloc and os.path.isfile(confloc):
        config.read(confloc)
        server = config.get("client", "server")
        if use_kerberos:
            port = config.get("client", "krbport")
        else:
            port = config.get("client", "sslport")
    pargs.pdb_hostname = server
    pargs.pdb_port = port
    if not (pargs.pdb_hostname and pargs.pdb_port):
        sys.stderr.write("need server and port defined")  # TODO:  ab it more specific please
        sys.exit(3)
    roger = teigi.rogerclient.RogerClient(pargs.pdb_hostname, int(pargs.pdb_port))
    url = roger.state_url(host)
    try:
        answer = roger.open_url(url)
    except urllib2.HTTPError, e:
        if e.code == 401:
            sys.stderr.write("Not authorized to view '%s'" % host)
            sys.exit(3)
        elif e.code == 404:
            return None
    except urllib2.URLError, e:
        sys.stderr.write("Cannot open url '%s': '%s'" % (url, e))
        sys.exit(3)
    return answer


def get_enc_data(pargs, hostname):
    enc = do_request_yaml(pargs.foreman_hostname, 8007, "node/%s?format=yml" % (hostname))
    return enc

def host_main(pargs):
    hostname = fqdnify(pargs.hostname)
    host_endpoint = "/v3/nodes/%s" % hostname

    host_info = do_request(pargs.pdb_hostname, pargs.pdb_port, host_endpoint, pargs.show_urls)
    if not host_info:
        sys.stderr.write('Host not found in PuppetDB!\n')
        sys.exit(1)
    deactivated = host_info['deactivated']
    if deactivated:
        sys.stderr.write("This host was deactivated in PupeptDB at %s (%s)\n" % (deactivated,
               pytz.UTC.localize(datetime.datetime.utcnow()) - iso8601.parse_date(host_info['deactivated'])))
        sys.stderr.write("Either the host was deleted or it hasn't been running Puppet for some time.\n")
        sys.exit(2)

    facts_endpoint = "/v3/nodes/%s/facts" % hostname
    facts = do_request(pargs.pdb_hostname, pargs.pdb_port, facts_endpoint, pargs.show_urls)
    facts = dict([ (f['name'], f['value']) for f in facts ])

    json_landbsets = do_request(pargs.pdb_hostname, pargs.pdb_port,
                "/v3/nodes/%s/resources/Cernfw::Landbset" % hostname, pargs.show_urls)
    landbsets = ', '.join([ j['title'] for j in json_landbsets ]) or '-'

    json_lbaliases = do_request(pargs.pdb_hostname, pargs.pdb_port,
                "/v3/nodes/%s/resources/Lbd::Client" % hostname, pargs.show_urls)
    lbaliases = ', '.join([ j['parameters']['lbalias'] for j in json_lbaliases ]) or '-'


    roger = get_roger_client(pargs, hostname)

    cnames = facts.get('landb_ip_aliases',None)
    if cnames:
        cnaliases = ', '.join([ '%s.cern.ch' % c for c in cnames.lower().split(',')])
    else:
        cnaliases = '-'

    ago = pytz.UTC.localize(datetime.datetime.utcnow()) - iso8601.parse_date(host_info['catalog_timestamp'])

    if facts['is_virtual'] == 'true':
        vtype = "virtual"
    else:
        vtype = "physical"

    disks = len(facts['disks'].split(","))

    enc = get_enc_data(pargs, hostname)

    if pargs.print_json:
        # Dump as JSON

        hardware = {"cores": facts['processorcount'], "memory": facts['memorysize'], "swap": facts['swapsize'],
                    "disks": disks, "type": vtype}
        jj = {  "hostname": hostname, "hardware": hardware, "hostgroup": facts['hostgroup'],
                "responsible": facts['landb_responsible_email'], "os": facts['operatingsystem'],
                "lsbdistrelease": facts['lsbdistrelease'], "arch": facts['architecture'],
                "kernel": facts['configured_kernel'], "landbsets": landbsets, "lbaliases": lbaliases,
                "ipaddress": facts['ipaddress'], "ipdomain": facts['landb_network_domain'],
                "uptime": facts['uptime'], "lastreport": host_info['catalog_timestamp'],
                "environment": enc["environment"], "comment": enc["parameters"]["comment"],
                "cnames": cnaliases, "landb_service_name": facts.get('landb_service_name', '-'),
                "aidump_recordversion": 1}

        if roger:
            rogga = {"appstate": roger['appstate'],
                     "hw_alarmed": roger['hw_alarmed'],
                     "os_alarmed": roger['os_alarmed'],
                     "app_alarmed": roger['app_alarmed'],
                     "nc_alarmed": roger['nc_alarmed'] }
            jj.update(rogga)

        if facts['is_virtual'] == 'true':
            jj['flavour'] = facts['ec2_instance_type']
            jj['availability_zone'] = facts['ec2_placement_availability_zone']
        else:
            jj['landb_location'] = facts['landb_location']
            jj['location_name'] = location_name(facts['landb_location'])

        print json.dumps([jj], sort_keys=True,
                             indent=4, separators=(',', ': '))

    else:
        # Text output

        t = prettytable.PrettyTable(["Item","Value"])
        t.add_row(["Hostname:", "%s   (uptime: %s)" % (hostname, facts['uptime'])])
        t.add_row(["Hardware:", "%s, %s cores, %s memory, %s swap, %i disks" % (vtype, facts['processorcount'],
                                                                                facts['memorysize'], facts['swapsize'], disks )] )
        t.add_row(["Hostgroup:", facts['hostgroup']])
        t.add_row(["Comment:",enc["parameters"]["comment"]])
        t.add_row(["Environment:",enc['environment']])
        t.add_row(["Responsible:", facts['landb_responsible_email']])
        t.add_row(["OS:", "%s %s %s (%s)" % (facts['operatingsystem'], facts['lsbdistrelease'], facts['architecture'], facts['configured_kernel'])])
        if facts['is_virtual'] == 'true':
            t.add_row(["VM Flavour:", facts['ec2_instance_type']])
            t.add_row(["Avail zone:", facts['ec2_placement_availability_zone']])
        else:
            location = location_name(facts['landb_location'])
            t.add_row(["LanDB Location:", "%s %s" % (facts['landb_location'], location)])

        t.add_row(["LANDBsets:", landbsets])
        t.add_row(["LB aliases:", lbaliases])
        t.add_row(["CNAME aliases:",cnaliases])
        t.add_row(["IP:", "%s (%s) (%s)" % (facts['ipaddress'], facts['landb_network_domain'], facts.get('landb_service_name', '-'))])

        if roger:
            t.add_row(["App state:", roger['appstate']])
            rh = roger['hw_alarmed'] and 'Y' or 'N'
            ro = roger['os_alarmed'] and 'Y' or 'N'
            ra = roger['app_alarmed'] and 'Y' or 'N'
            rn = roger['nc_alarmed'] and 'Y' or 'N'
            t.add_row(["Alarm state:", "Hardware(%s) OS(%s) App(%s) NoContact(%s)" %(rh, ro, ra, rn)])
        else:
            t.add_row(["App state:", "[not yet registered in Roger]"])
            t.add_row(["Alarm state:", "[not yet registered in Roger]"])

        t.add_row(["",""])
        t.add_row(["Last Puppet report:", humanize.naturaltime(ago)])

        t.border=True
        t.header=False
        t.align["Item"] = 'r'
        t.align["Value"] = 'l'

        print t

def main():
    parser = ArgumentParser(description="wrap puppetdb commands")
    add_common_puppetdb_args(parser)
    add_common_foreman_args(parser)
    parser.add_argument("--show_url", action="store_true", default=False, dest="show_urls",
                        help="show REST urls")
    parser.add_argument("--json", action="store_true", default=False, dest="print_json",
                        help="output in JSON format")
    parser.add_argument("hostname", metavar="HOST", help="hostname to dump").completer = ForemanCompleter()
    argcomplete.autocomplete(parser)
    parser.set_defaults(func=host_main)

    pargs = parser.parse_args()
    pargs.func(pargs)

if __name__ == "__main__":
    main()
