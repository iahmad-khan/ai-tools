#! /usr/bin/perl -w

# To-do:

use strict;
use diagnostics;
use POSIX;
use Getopt::Long;
use Data::Dumper;
#use SOAP::Lite;# +trace => 'debug';
use SOAP::Lite + maptype => {};
use SOAP::Transport::HTTP;
use LWP;
use JSON;
use Socket;
use NetAddr::IP;
use Date::Manip;
use Switch;
use DateTime;

$Data::Dumper::Sortkeys = 1;

sub ForemanConfig($$);
sub LandbHostInfo(@);
sub ShowHost($@);
sub ShowConfig($);
sub DeleteHost($@);
sub CreateVM($@);
sub ChkHost(@);
sub UpdateHost($@);
sub InstallHost(@);
sub SetupAims($);
sub GetUserCredentials($);
sub HelpMessage(;$);
sub HandleOptions();

HelpMessage("No arguments given.") if not @ARGV;

my $debug = my $verbose = my $dryrun = 0;
my %user_credentials = ();

my ($action,%opts) = HandleOptions();

#print "\@ARGV @ARGV\n";

#print Dumper(\%opts);#exit;

$verbose = 1 if $debug;


my @host = @ARGV;
if (not @host and not ($action eq "showhost" or $action eq "showconfig")){
    print STDERR "[ERROR] No hostname(s) given...\n";
    exit 1;
}

map {s/.cern.ch//; $_ = lc} @host;  # strip domain name, change to lower case

#
# Get user credentials
#
($user_credentials{username},$user_credentials{password}) = GetUserCredentials($user_credentials{username});

#
# Connect to Foreman
#
my $url         = "https://punch.cern.ch";
my $netlocation = "punch.cern.ch:443";
my $realm       = "Application";
my $browser     = LWP::UserAgent->new;
$browser->credentials($netlocation,$realm,$user_credentials{username} => $user_credentials{password});

#
# Does the user have administrator privileges?
#
my $request = HTTP::Request->new("GET","$url/users");
$request->header("Content-Type" => "application/json");
my $response = $browser->request($request);
if (not $response->is_success){
    print STDERR "[ERROR] Could not retrieve list of users from Foreman: \"".$response->status_line."\"\n";
    exit 1;
}
for (grep { ${$$_{user}}{login} eq $user_credentials{username} } @{from_json($response->content)}){
    my %tmp = %$_;
    $user_credentials{administrator} = defined ${$tmp{user}}{admin} ? 1 : 0;
}

if (not $user_credentials{administrator}){
    print STDERR "[ERROR] This tool currently requires admin privileges on Foreman.\n";
    exit 1;
}

#
# Easy things first.
#
if ($action eq "delhost"){
    DeleteHost(\%opts,@host);
    exit 0;
}elsif ($action eq "createvm"){
    CreateVM(\%opts,@host);
    exit 0;
}elsif ($action eq "chkhost"){
    ChkHost(@host);
    exit 0;
}

#
# Resolve Foreman ID's, update host data.
#
my %fmdata = ForemanConfig($browser,$url);

#
# More easy things.
#
if ($action eq "showhost"){
    ShowHost(\%opts,@host);
    exit 0;
}elsif ($action eq "installhost"){
    InstallHost(@host);
    exit 0;
}elsif ($action eq "showconfig"){
    ShowConfig(\%fmdata);
    exit 0;
}

#
# Do the user options have correct values?
#
my @err = ();
for my $attr (qw(architecture model operatingsystem hostgroup environment domain ptable owner)){
    next if not defined $opts{$attr};
    my @values = ($attr eq "owner" ? sort values %{$fmdata{user}}, values %{$fmdata{usergroup}} : sort values %{$fmdata{$attr}} );
    next if grep {$opts{$attr} eq $_} @values;
    my $msg = "[ERROR] Option \"--$attr\" has unknown value \"$opts{$attr}\". Valid values:\n";
    push(@err,$msg);
    while (my @tmp = splice(@values,0,5)){
	last if not @tmp;
	my $msg = "[ERROR]          ";
	map {$msg .= sprintf "%-30s ", /\s/ ? "\"$_\"" : $_} @tmp;
	push(@err,"$msg\n");
    }
}
if (@err){
    map {print STDERR $_} @err;
    exit 1;
}

#
# Do the real work
#
if ($action eq "addhost" or $action eq "updatehost"){
    my @done = UpdateHost({%opts,("action" => $action)},@host);
    if (@done){
	print STDOUT "\n[INFO] Summary:\n\n";
	ShowHost(undef,@done);
	print STDOUT "\n";
    }
}

exit 0;

################################################################################################
#
# ShowHost(): display host information
#
sub ShowHost($@){
    my ($href,@host) = @_;
    my %opt = defined $href ? %$href : ();
    print "[DEBUG] ".Dumper(\%opt,\@host) if $debug;
    if ($opt{all} or $opt{regexp}){
	my $request = HTTP::Request->new("GET","$url/hosts");
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if (not $response->is_success){
	    print STDERR "[ERROR] Could not retrieve list of hosts from Foreman...\n";
	    return -1;
	}
	if ($opt{all}){
	    @host = sort @{from_json($response->content)};	
	    map {s/.cern.ch//; $_ = lc} @host;  # strip domain name, change to lower case
	}elsif ($opt{hostname} and $opt{regexp}){
	    my %host = ();
	    my @list = @{from_json($response->content)};
	    for my $hostname (@{$opt{hostname}}){
		map {s/.cern.ch//;$host{$_}++ if /$hostname/i} @list;
	    }
	    push(@host,keys %host);
	}
	print STDOUT "[INFO] Parsing information for ".scalar(@host)." machines - this may take a while...\n";
    }elsif ($opt{hostname}){
	push(@host,map {s/.cern.ch//; $_ = lc} @{$opt{hostname}});
    }
    #print Dumper(\%opt); print "\@host = \"@host\"\n";
    #exit;

    my $FORMAT = " %-15s %-30s %-15s %-15s %-6s  %-25s %-15s %s\n";
    #
    # Are the hosts known to Foreman?
    #
    my @out = ();
    for my $host (sort @host){
	my $request = HTTP::Request->new("GET","$url/hosts/$host" . ($host !~ /\./ ? ".cern.ch" : ""));
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if (not $response->is_success){
	    print STDERR "[ERROR] Host \"$host\" is unknown to Foreman...\n";
	    #print Dumper($response);
	    next;
	}
	print "[DEBUG] JSON: ".$response->content."\n" if $debug;
	my %data = %{from_json($response->content)};
	%data = %{$data{host}};
	my $ownertype = lc($data{owner_type}); # values: "user", "usergroup"
	#print "\$ownertype = \"$ownertype\" \n".Dumper(\%{$fmdata{$ownertype}});
	#print Dumper(\%data);exit;
	#printf "%15s %-15s %15s %-15s %15s\n",$host,map {$data{$_} || "oops..."} qw(environment_id owner_id ip managed) if $debug;

	# make "Comment" field fit to print
	$data{comment} ||= "";
	$data{comment} =~ s/\n//g;
	$data{comment} =~ s/\s+/ /g;

	$data{operatingsystem} = $fmdata{operatingsystem}{ $data{operatingsystem_id} || -1 } || "";
	$data{architecture}    = $fmdata{architecture}   { $data{architecture_id}    || -1 } || "";
	$data{hostgroup}       = $fmdata{hostgroup}      { $data{hostgroup_id}       || -1 } || "";
	$data{environment}     = $fmdata{environment}    { $data{environment_id}     || -1 } || "";
	$data{owner}           = $fmdata{$ownertype}     { $data{owner_id}           || -1 } || "";
	$data{model}           = $fmdata{model}          { $data{model_id}           || -1 } || "";

	# apply filters
	my $ok = 1;
	for my $attribute (grep {exists $opt{$_}} qw(operatingsystem architecture hostgroup environment owner model comment)){
	    #print "OK $host \$attribute = \"$attribute\" @{$opt{$attribute}}\n";
	    if ($opt{regexp}){
		$ok = 0 unless grep {$data{$attribute} =~ /$_/i} @{$opt{$attribute}};
	    }else{
		$ok = 0 unless grep {lc($_) eq lc($data{$attribute})} @{$opt{$attribute}};
	    }
	    last if not $ok;
	}
	next if not $ok;

	#print Dumper(\%fmdata);
	#
	push(@out,sprintf $FORMAT, $host, map {$data{$_}} qw(hostgroup environment operatingsystem architecture model owner comment));
    }

    if (@out){
	printf STDOUT $FORMAT,qw(Hostname Hostgroup Environment OS Arch Hardware-model Owner Comment);
	printf STDOUT $FORMAT,qw(======== ========= =========== == ==== ============== ===== =======);
	map {print STDOUT $_} @out;
	return 0;
    }else{
	print STDERR "[ERROR] No machines found\n";
	return -1;
    }

}

################################################################################################
#
# DeleteHost(): delete host
#
sub DeleteHost($@){
    my ($href,@host) = @_;
    my %opt = %$href;
    #
    # Are the hosts known to Foreman?
    #
    my @err = ();
    for my $host (sort @host){
	my $request = HTTP::Request->new("DELETE","$url/hosts/$host.cern.ch");
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if ($response->is_success){
	    print STDOUT "[INFO] Deleted \"$host\" from Foreman.\n";
	}else{
	    push(@err,$host);
	}
    }
    if (@err){
	print STDERR "[ERROR] Could not delete host(s) \"".join("\" - \"",@err). "\" from Foreman.\n";
	return 1;
    }
    return 0;
}

################################################################################################
#
# ChkHost(): perform consistency checks 
#
sub ChkHost(@){
    my @host = @_;

    #
    # Are the hosts known to Foreman?
    #
    my @err = my %todo = ();
    for my $host (@host){
     	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
     	$request->header("Content-Type" => "application/json");
     	my $response = $browser->request($request);
	if (not $response->is_success){
     	    print STDERR "[ERROR] No host \"$host\" known to Foreman\n";
      	    next;
	}
	#
	my @error = ();
     	my %data = %{${from_json($response->content)}{host}};
	#print Dumper(\%data);exit;
	
	# IP address?
	my $iaddr = gethostbyname($host);
	die "aargh..." if not defined $iaddr;
	$iaddr = inet_ntoa($iaddr);
	push(@error,"$host: IP address in Foreman is $data{ip}, but DNS says $iaddr") if $data{ip} ne $iaddr;
	
	# IPMI ip-address?
	if (exists $data{sp_ip} and $data{sp_name}){
	    my $iaddr = gethostbyname($data{sp_name});
	    die "aargh..." if not defined $iaddr;
	    $iaddr = inet_ntoa($iaddr);
	    push(@error,"$data{sp_name}: IP address in Foreman is $data{sp_ip}, but DNS says $iaddr") if $data{sp_ip} ne $iaddr;
	}

	# print result
	if (@error){
	    map {print "[$host] $_\n"} @error;
	}else{
	    print "[$host] OK\n";
	}
    }
    return;
}

################################################################################################
#
# InstallHost(): generate kickstart files, call out to AIMS
#
sub InstallHost(@){
    my @host = @_;

    #
    # Show the hosts
    #
    print STDOUT "[INFO] Installation requested for" . (scalar(@host) == 1 ? "" : " " .scalar(@host) ." machines" ) . ":\n\n";
    ShowHost(undef,@host);
    print STDOUT "\n";

    #
    # Are the hosts known to Foreman?
    #
    my @err = my %todo = ();
    for my $host (@host){
     	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
     	$request->header("Content-Type" => "application/json");
     	my $response = $browser->request($request);
	push(@err,"Host \"$host\" unknown to Foreman") unless $response->is_success;
	next if @err;
	#
     	my %data = %{from_json($response->content)};
	
	my $iaddr = gethostbyname($host);
	if (not defined $iaddr){
	    push(@err,"Cannot get IP address from DNS for host \"$host\"");
	    next;
	}
	$iaddr = inet_ntoa($iaddr);
	if ($data{host}{ip} ne $iaddr){
	    push(@err,"IP-address differs between Foreman (\"$data{host}{ip}\") and DNS (\"$iaddr\"). Consider running \"ai-foreman-cli updatehost --network $host\"");
	    next;
	}
	# store relevant information
	$todo{$host}{operatingsystem} = $fmdata{operatingsystem}{$data{host}{operatingsystem_id}};
	$todo{$host}{architecture}    = $fmdata{architecture}   {$data{host}{architecture_id}   };
	$todo{$host}{model}           = $fmdata{model}          {$data{host}{model_id}          };
	$todo{$host}{hostname}        = $host;

	my ($owner_id,$owner_type) = ($data{host}{owner_id},$data{host}{owner_type});
	if ($owner_type eq "User"){
	    $todo{$host}{owner} = $fmdata{user}{$owner_id};
	}elsif ($owner_type eq "Usergroup"){
	    $todo{$host}{owner} = $fmdata{usergroup}{$owner_id};
	}
	#print Dumper(\%fmdata);
     	#print Dumper(\%data);
	#print Dumper(\%todo);exit;
    }
    if (@err){
     	map {print STDERR "[ERROR] $_\n"} @err;
     	exit 1;
    }
    print STDOUT "[VERBOSE] Retrieved host information from Foreman\n" if $verbose;

    #
    # Delete certs
    #
    @err = ();
    for my $host (keys %todo){
	my $request = HTTP::Request->new("DELETE","$url/smart_proxies/2-punch-cern-ch/puppetca/$host.cern.ch"); # XXX to-do: replace hardcoded URL by sthg smart :)
	$request->header("Content-Type" => "application/json");
	if ($dryrun){
	    print STDOUT "[INFO] Dryrun: request to delete certificate for \"$host\" deliberately not submitted\n";
	    next;
	}
	my $response = $browser->request($request);
	if (not $response->is_success){
	    push(@err,$host);
	    print "[ERROR] ".$response->status_line."\n" if $debug;
	}else{
	    print STDOUT "[DEBUG] Deleted certificate for \"$host\" from Puppet CA: ".$response->status_line."\n" if $debug;
	}
	#print Dumper(\$response);exit;
    }
    if (@err){
	print STDERR "[WARN] Could not delete certificate for host(s) \"".join("\" - \"",@err). "\" from Puppet Certificate Authority...\n";
	#exit 1;
    }
    print STDOUT "[VERBOSE] Deleted certificates from Puppet CA\n" if $verbose;
    
    #
    # Prepare Kickstart file
    #
    for my $host (sort keys %todo){

	my %data = (USER => $user_credentials{username});

	if (gethostbyname("${host}-gigeth")){
	    print "[INFO] Getting LANdb info for host \"$host\", patience please...\n";
	    my %landb = LandbHostInfo($host);
	    #print Dumper(\%landb);
	    if (not %landb){
		print "[WARNING] Could not get Landb info for \$host\", skipping it...\n";
		next;
	    }
	    $data{NETWORK}  = "\n#\n# - onboot=yes for the 10GB interface, specify hostname";
	    $data{NETWORK} .= "\n# - onboot=no  for the  1GB interface, do *not* specify a hostname!\n#\n\n";
	    for my $name (keys %{$landb{$host}{Interfaces}}){
		my $mac = $landb{$host}{Interfaces}{$name}{HardwareAddress};
		if ($name eq $host){
		    $data{NETWORK} .= "network --bootproto=dhcp --device=$mac --onboot=yes --hostname $host.cern.ch\n";
		} elsif ($name eq "${host}-gigeth"){
		    $data{NETWORK} .= "network --bootproto=dhcp --device=$mac --onboot=no\n";
		}
	    }
	    #print $data{NETWORK};exit;
	    $todo{$host}{hostname} .= "-gigeth";
	#}else{
	#    $data{NETWORK} = "network --bootproto=dhcp --device=eth0 --hostname $host.cern.ch";
	#    $todo{$host}{hostname} = $host;
	}
	
	# my $model = $data{HWMODEL} = $todo{$host}{model};

	# if (uc($data{HWMODEL}) eq "HYPER-V VIRTUAL MACHINE" and $todo{$host}{operatingsystem} =~ /^(SLC|RedHat) 5\./){
	#     $data{FIRST_DRIVE} = "hda";
	# } else {
	#     $data{FIRST_DRIVE} = "sda";
	# }

	# Get the KS file from Foreman
	my $iaddr = gethostbyname($host);
	die "aargh..." if not defined $iaddr;
	$iaddr = inet_ntoa($iaddr);
	my $ksfile = "$url/unattended/provision?spoof=$iaddr";
	my $request = HTTP::Request->new("GET",$ksfile);
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if (not $response->is_success){
	    print STDERR "[ERROR] Failed to retrieve a Kickstart file \"$ksfile\":\n";
	    print STDERR "[ERROR]   ".$response->content."\n";
	    #print STDERR Dumper($response)."AARGH! $url/unattended/provision?spoof=$iaddr\n";
	    exit;
	}
	my $template = $response->content;

	use Text::Template;
	my $tpl = new Text::Template(TYPE    => "STRING",
				     UNTAINT => 1,
				     SOURCE  => $template) or die "Couldn't construct template: $Text::Template::ERROR";

	my $result = $tpl->fill_in(HASH => \%data);
	if (not defined $result) {
	    print STDERR "Couldn't fill in template: $Text::Template::ERROR\n";
	    next;
	}
    
	$todo{$host}{ksfile} = POSIX::tmpnam();
	if (not open(F,"> $todo{$host}{ksfile}")){
	    print STDERR "[ERROR] Could not open \"$todo{$host}{ksfile}\" for writing: $!\n";
	    next;
	}
	print F $result;
	print $result if $debug;
	close F;
    
    }
    #print Dumper(\%todo);exit;

    #
    # Upload to AIMS
    #
    @host = SetupAims(\%todo);
    if (not @host){
	print STDERR "[ERROR] Upload to AIMS failed, exiting...\n";
	exit 1;
    }

    #my $mess1 = join("\n",map {"      ssh root\@punch puppetca --clean $_.cern.ch"} @host);
    my $mess2 = join("\n",map {"      ssh root\@$_ shutdown -r now"} @host);
    my $mess3 = "      ssh lxadm remote-power-control reset ". join(",",@host)."\n";
    #my $mess3 = join("\n",map {"      ssh lxadm remote-power-control reset $_"} @host);
    my $mess4 = join("\n",map {"      ssh lxadm connect2console.sh $_"} @host);
    #my $mess5 = undef;
    #map {$mess5 .= "      aims2 pxeoff $_-gigeth\n" if gethostbyname($_ . "-gigeth")} @host;

    print <<EOMESS;

-- Reboot the host to start the installation:

$mess2

   or

$mess3

-- To see installation in progress:

$mess4

EOMESS

#     if ($mess5){
# 	print <<EOMESS;

# -- IMPORTANT NOTE FOR "*-GIGETH" MACHINES: once the installation is underway, run 

# $mess5
#     to break out on an install loop
# EOMESS
#     }

    return 0;
}

################################################################################################
#
# UpdateHost(): update host information
#
sub UpdateHost($@){
    my ($href,@host) = @_;
    my %opt = %$href;
    print Dumper(\%opt) if $debug;

    my $action = $opt{action};
    delete $opt{action};
    if (not grep {$_ eq $action} qw(addhost updatehost)){
	print STDERR "[ERROR] UpdateHost: unsupported action \"$action\" specified\n";
	return undef;
    }

    #print "@host\n";

    #
    # get network data
    #
    my %landb = my %subnet = ();
    if ($opt{network}){
	%landb = LandbHostInfo(@host);
	print Dumper(\%landb) if $debug;
	for (@{from_json($browser->get("$url/subnets?format=json")->content)}){
	    my %tmp = %{$$_{subnet}};
	    %{$subnet{$tmp{id}}} = (network => $tmp{network}, mask => $tmp{mask});
	}
	#print Dumper(\%subnet);#exit;
    }

    #
    # installation media
    #
    if (defined $opt{operatingsystem} and not defined $opt{medium}){
	switch ($opt{operatingsystem}) {
	    case /^SLC/      { $opt{medium} = "SLC"           }
	    case /^RedHat 6/ { $opt{medium} = "RedHat 6"      }
	    case /^Fedora/   { $opt{medium} = "Fedora Mirror" }
	}
	if (not defined $opt{medium}){
	    print STDERR "[ERROR] UpdateHost: no medium defined for operating system \"$opt{operatingsystem}\"\n";
	    return undef;
	}
    }
    print Dumper(\%opt) if $debug;
  
    #
    # build the data structure to be sent to Foreman
    #
    my %data = my @err = ();

    for my $attr (keys %opt){
	for (keys %{$fmdata{$attr}}){
	    if (lc(${$fmdata{$attr}}{$_}) eq lc($opt{$attr})){
		$data{"${attr}_id"} = $_;
		last;
	    }
	}
	push(@err,"Could not find Foreman identifier for attribute \"$attr\" with requested value \"$opt{$attr}\"") if not exists $data{"${attr}_id"} and %{$fmdata{$attr}};
    }
    if (@err){
	map {print STDERR "[ERROR] $_\n"} sort @err;
	return undef;
    }
    
    # comment (if any)
    $data{comment} = exists $opt{comment} ? $opt{comment} : undef;

    # set the ownership information
    if (exists $opt{owner}){
	if (grep {$opt{owner} eq $_} values %{$fmdata{user}}){
	    $data{owner_type} = "User";
	}elsif (grep {$opt{owner} eq $_} values %{$fmdata{usergroup}}){
	    $data{owner_type} = "Usergroup";
	}else{
	    print STDERR "[ERROR][BUG] Unsupported ownertype detected, exiting\n";
	    exit 1;
	}
	for my $id (keys %{$fmdata{lc($data{owner_type})}}){
	    if (${fmdata{lc($data{owner_type})}}{$id} eq $opts{owner}){
		$data{owner_id} = $id;
		last;
	    }
	}
    }

    #
    #
    #
    print Dumper(\%fmdata) if $debug;#exit;
    my @done = ();
    for my $host (sort @host){
	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if ($action eq "addhost" and $response->is_success){
	    print STDERR "[WARN] Ignoring existing host \"$host\".\n";
	    next;
	}elsif ($action eq "updatehost" and not $response->is_success){
	    print STDERR "[WARN] Ignoring non-existent host \"$host\".\n";
	    next;
	}
	print STDOUT "[VERB] " . ($action eq "addhost" ? "Adding" : "Updating") . " \"$host\"\n" if $verbose;

	#
	# Network info
	#
	if ($opt{network}){
	    my %network = ();
	    for my $interface (keys %{$landb{$host}{Interfaces}}){
		next unless ($interface eq $host or $interface eq "${host}-ipmi");
		my $ipaddr = $landb{$host}{Interfaces}{$interface}{IPAddress};
		my $subnet_id = undef;
		my $ip = NetAddr::IP->new($ipaddr);
		for my $id (keys %subnet){
		    if ($ip->within(NetAddr::IP->new($subnet{$id}{network},$subnet{$id}{mask}))){
			$subnet_id = $id;
			last;
		    }
		}
		if (not defined $subnet_id){
		    print STDERR "[ERROR] Could not get subnet_id for host $interface, exiting!\n";
		    exit 1;
		}

		my $prefix = $interface eq $host ? "" : "sp_"; # Ordinary interface, or IPMI?
		$network{$prefix . "name"}      = $interface;
		$network{$prefix . "mac"}       = $landb{$host}{Interfaces}{$interface}{HardwareAddress};
		$network{$prefix . "ip"}        = $ipaddr;
		$network{$prefix . "subnet_id"} = $subnet_id;
	    }
	    %data = (%data, %network);
	}

	#
	# Sanity checks
	#
        map {delete $data{$_} if not defined $data{$_}} keys %data;
	if (not %data and $action eq "updatehost"){
	    print STDERR "[ERROR] Nothing to update?!\n";
	    last;
	}
	print Dumper(\%data) if $debug;#exit;

	if ($opt{network} and not exists $data{name}){
	    print STDERR "[ERROR] Incomplete network information for host \"$host\", skipping it...\n";
	    next;
	}

	#
	# Action!
	#
     	$request = HTTP::Request->new($action eq "updatehost" ? ("PUT","$url/hosts/$host.cern.ch") : ("POST","$url/hosts") );
     	$request->header("Content-Type" => "application/json");
	print "[DEBUG] JSON: ".to_json({host => \%data})."\n" if $debug;
     	$request->content(to_json({host => \%data}));
	
     	$response = $browser->request($request);
	
     	if ($response->is_success){
	    print STDOUT "[INFO] Successfully " . ( $action eq "addhost" ? "added" : "updated" ) . " $host\n";
	    push(@done,$host);
	}else{
     	    print STDERR "[ERROR] Cannot " . ( $action eq "addhost" ? "add" : "update" ) . " \"$host\": " . $response->status_line . " :: " . $response->content ."\n";
     	}
    }

    return @done;
}

################################################################################################
#
# ForemanConfig(): retrieve Foreman configuration information
#
sub ForemanConfig($$){
    my ($browser,$url) = @_;
    my %config = ();

    # record ptable per OS
    my %ptable = my %medium = ();
    for (@{from_json($browser->get("$url/operatingsystems?format=json")->content)}){
	my %data = %{$$_{operatingsystem}};
	#print Dumper(\%data);#exit;
	for (@{$data{ptables}}){
	    my %pt = %{$$_{ptable}};
	    my $name = $pt{name};
	    $ptable{$name}++;
	}
	for (@{$data{media}}){
	    my %med = %{$$_{medium}};
	    my $name = $med{name};
	    $medium{$name}++;
	}
    }
    #print Dumper(\%medium);exit;

    # partition tables
    map {$config{ptable}         {$$_{ptable}         {id}} = $$_{ptable}         {name} } @{from_json($browser->get("$url/ptables?format=json")->content)};
    map {delete $config{ptable}{$_} unless exists $ptable{$config{ptable}{$_}}} keys %{$config{ptable}}; # remove ptables that are supported for unsupported OS-es :)

    # installation media
    map {$config{medium}         {$$_{medium}         {id}} = $$_{medium}         {name} } @{from_json($browser->get("$url/media?format=json")->content)};
    map {delete $config{medium}{$_} unless exists $medium{$config{medium}{$_}}} keys %{$config{medium}}; # remove media that are supported for unsupported OS-es :)

    map {$config{operatingsystem}{$$_{operatingsystem}{id}} = $$_{operatingsystem}{name} } @{from_json($browser->get("$url/operatingsystems?format=json")->content)};
    map {$config{architecture}   {$$_{architecture}   {id}} = $$_{architecture}   {name} } @{from_json($browser->get("$url/architectures?format=json")->content)};
    map {$config{model}          {$$_{model}          {id}} = $$_{model}          {name} } @{from_json($browser->get("$url/models?format=json")->content)};
    map {$config{hostgroup}      {$$_{hostgroup}      {id}} = $$_{hostgroup}      {label}} @{from_json($browser->get("$url/hostgroups?format=json")->content)};
    map {$config{environment}    {$$_{environment}    {id}} = $$_{environment}    {name} } @{from_json($browser->get("$url/environments?format=json")->content)};
    map {$config{user}           {$$_{user}           {id}} = $$_{user}           {login}} @{from_json($browser->get("$url/users?format=json")->content)};
    map {$config{usergroup}      {$$_{usergroup}      {id}} = $$_{usergroup}      {name} } @{from_json($browser->get("$url/usergroups?format=json")->content)};
    map {$config{domain}         {$$_{domain}         {id}} = $$_{domain}         {name} } @{from_json($browser->get("$url/domains?format=json")->content)};
    #map {$config{subnet}         {$$_{subnet}         {id}} = $$_{subnet}         {name} } @{from_json($browser->get("$url/subnets?format=json")->content)};
    #%{$config{sp_subnet}} = %{$config{subnet}};

    #print Dumper(\@{from_json($browser->get("$url/usergroups?format=json")->content)});exit;
    #print Dumper(\%config);exit;
    return %config;
}

################################################################################################
#
# LandbHostInfo(): retrieve host information from LANdb
#
sub LandbHostInfo(@){
    my @device = @_;

    my $client = SOAP::Lite
	->uri('http://network.cern.ch/NetworkService')
	->xmlschema('http://www.w3.org/2001/XMLSchema')
	->proxy('https://network.cern.ch/sc/soap/soap.fcgi?v=4', keep_alive=>1);

    # Get Auth token
    my $call = $client->getAuthToken($user_credentials{username},$user_credentials{password},'NICE');
    
    my ($auth) = $call->result;
    if ($call->fault){
        print "ERROR: failed to authenticate to LANdb.\n";
        exit 1;
    }

    my $authHeader = SOAP::Header->name('Auth' => { "token" => $auth });

    my %landb = ();
    for my $device (@device){
	$call = $client->getDeviceInfo($authHeader,$device);
	
	my $bu = $call->result;
	if ($call->fault) {
	    print "[WARNING] Device \"$device\" not found in Landb, ignoring it...\n";
	    next;
	}
	#print Dumper($bu);exit;

	$landb{$device}{Model} = $bu->{Model};
	for (@{$bu->{Interfaces}}) {
	    #print Dumper(\$_);
	    my $Name = lc($_->{Name});
	    my $HardwareAddress = $_->{BoundInterfaceCard}->{HardwareAddress};
	    my $IPAddress = $_->{IPAddress};
	    if (defined $HardwareAddress){
		$HardwareAddress =~ s/\-/:/g;
		%{$landb{$device}{Interfaces}{$Name}} = (HardwareAddress => $HardwareAddress, IPAddress => $IPAddress);
	    }
	}
	if (not exists $landb{$device}{Interfaces}){
	    my $Name = lc($bu->{DeviceName});
	    for (@{$bu->{NetworkInterfaceCards}}) {
		my $HardwareAddress = $_->{HardwareAddress};
		my $IPAddress = $_->{IPAddress};
		if (defined $HardwareAddress){
		    $HardwareAddress =~ s/\-/:/g;
		    ${$landb{$device}{Interfaces}{$Name}}{HardwareAddress} = $HardwareAddress;
		}
	    }
	    for (@{$bu->{Interfaces}}) {
		if ($Name eq lc($_->{Name})){
		    ${$landb{$device}{Interfaces}{$Name}}{IPAddress} = $_->{IPAddress};
		}
	    }
	}
    }

    #print Dumper(\%landb);
    #exit;

    return %landb;
}

################################################################################################
#
# SetupAims(): upload Kickstart file to AIMS, and configure it
#
sub SetupAims($){
    my $href = shift @_;
    my %todo = %$href;
    #print Dumper(\%todo);exit;

    # Run "aims2 showimg all" to get list of all available AIMS images
    my %AimsImg = (
        "SLC 6.2"    => "SLC62",
        "SLC 6.1"    => "SLC61",
        "SLC 6"      => "SLC6X",
        "SLC 5.8"    => "SLC58",
        "SLC 5.7"    => "SLC57",
	#
        "RedHat 6.2" => "RHEL6_U2",
        "RedHat 6.1" => "RHEL6_U1",
        "RedHat 6"   => "RHEL6_U2",
        "RedHat 5.8" => "RHES_5_U8",
        "RedHat 5.7" => "RHES_5_U7",
	#
	"Fedora 18"  => "FEDORA18",
	"Fedora 17"  => "FEDORA17",
	"Fedora 16"  => "FEDORA16",
	"Fedora 15"  => "FEDORA15",
        );
    
    #
    # Reshuffle input data
    #
    #print Dumper(\%todo);
    for my $oldname (keys %todo){
	my $newname = $todo{$oldname}{hostname};
	if ($newname ne $oldname){
	    %{$todo{$newname}} = %{$todo{$oldname}};
	    $todo{$newname}{hostname} = $oldname;
	    delete $todo{$oldname};
	}
    }
    #print Dumper(\%todo);exit;

    #
    # Upload the kickstart files
    #
    for my $host (sort keys %todo){
	my $cnt = 0;
	my $kopts = "text network ks ksdevice=bootif latefcload";
	#$kopts .= " $todo{$host}{console}" if $todo{$host}{console};
	my $model = lc($todo{$host}{model});
	$kopts .= " pcie_aspm=off" if $model eq "e4_09_21";
	# Console options
	use Switch;
	switch ($model) {
	    case "hyper-v virtual machine" { $kopts .= ""                                  }
	    case "ac_11_30"                { $kopts .= " console=tty0"                      }
	    case "hp_09_10"                { $kopts .= " console=tty0"                      }
	    case "py_08_10"                { $kopts .= " console=tty0"                      }
	    else                           { $kopts .= " console=tty0 console=ttyS2,9600n8" }
	}
	if (not exists $AimsImg{$todo{$host}{operatingsystem}}){
	    print STDERR "[ERROR] No suitable AIMS target for Operating System \"$todo{$host}{operatingsystem}\" available. Probably a bug in the script you are running :)\n";
	    exit 1;
	}
	$todo{$host}{aimstarget} = $AimsImg{$todo{$host}{operatingsystem}} . "_" . uc($todo{$host}{architecture});
	if ($todo{$host}{aimstarget} eq "SLC62_X86_64" and $model eq "hyper-v virtual machine"){
	    $todo{$host}{aimstarget} = "SLC62_X86_64_MSHVIC";
	}
	$todo{$host}{aimscmd}    = "/usr/bin/aims2client addhost --hostname $host --kickstart $todo{$host}{ksfile} --kopts \"$kopts\" --pxe --name $todo{$host}{aimstarget}";

	if ($dryrun){
	    print STDOUT "[DRYRUN] Deliberately *not* uploading Kickstart file for $host to AIMS\n";
	    next;
	}

	print STDOUT "[INFO] Uploading Kickstart file for $host to AIMS\n";
	print STDOUT "[VERB] Running \"$todo{$host}{aimscmd}\"\n" if $verbose;
	if (system("$todo{$host}{aimscmd} 2>/dev/null 1>/dev/null") != 0){
	    print STDERR "[ERROR] Upload to AIMS failed: $!\n";
	}
    }

    if ($dryrun){
	map {unlink $todo{$_}{ksfile}} keys %todo unless $debug;
	return (sort keys %todo);
    }

    #
    # Verify AIMS status
    #
    my $cnt = 0;
    my @done = ();
    while (1){
	#print "\$cnt = $cnt\n";
	#print Dumper(\%todo);
	print "[INFO] Verifying that AIMS is properly set up, patience please...\n";
	sleep 5;

	#
	# get status information
	#
	my $aims = "/usr/bin/aims2client showhost --full " . join(",",sort keys %todo);
	print "[VERB] Running \"$aims\"\n" if $verbose;
	open(AIMS,"$aims |") or die "aargh...";
	my $hostname = undef;
	my %status = ();
	while(<AIMS>){
	    chomp;
	    if (/^\s*Hostname:\s+(\S+)/){
		$hostname = lc($1);
	    }elsif (/^\s*PXE status:\s+(\S+)/){
		$status{$hostname}{pxestatus} = $1 if defined $hostname;
	    }elsif (/^\s*PXE boot synced:\s+(\S+)/){
		$status{$hostname}{syncstatus} = $1 if defined $hostname;
	    }
	}
	close AIMS;
	if ($debug){
	    map {printf "[DEBUG] %20s - PXE status = %3s - SYNC status = %3s\n",$_,($status{$_}{pxestatus} || "???"),($status{$_}{syncstatus} || "???")} sort keys %todo;
	}

	#
	# check if all is well
	#
	for my $hostname (sort keys %todo){
	    if (not exists $status{$hostname}){
		print STDOUT "[WARN] AIMS did nothing for host \"$hostname\". Re-uploading with \"$todo{$hostname}{aimscmd}\"\n";
		system("$todo{$hostname}{aimscmd}");
	    }elsif ($status{$hostname}{pxestatus} eq "OFF"){
		print STDOUT "[WARN] PXE status \"OFF\" for host \"$hostname\". Executing \"/usr/bin/aims2client pxeon $hostname $todo{$hostname}{aimstarget}\"\n";
		system("/usr/bin/aims2client pxeon $hostname $todo{$hostname}{aimstarget} 2>/dev/null 1>/dev/null");
		$cnt = 0;
	    }elsif (not grep {$_ eq $status{$hostname}{syncstatus}} qw(YYY YYN YNY NYY)){
		print STDOUT "[VERB] Sync status \"$status{$hostname}{syncstatus}\" for host \"$hostname\" -> Be patient...\n" if $verbose;
	    }else{
		print STDOUT "[INFO] Host \"$hostname\" is properly configured in AIMS\n";
		unlink $todo{$hostname}{ksfile} unless $debug;
		push(@done,$todo{$hostname}{hostname});
		delete $todo{$hostname};
	    }
	}
	#
	# anything left to do?
	#
	last if not %todo; 
	if (++$cnt == 12){
	    my @host = sort keys %todo;
	    my $dum = scalar(@host) == 1 ? "Machine \"@host\"" : "Machines \"".join("\", \"",@host)."\"";
	    print STDERR "[ERROR] $dum still not properly configured in AIMS, giving up...\n";
	    last;
	}
	print "[DEBUG] Loop again \$cnt = $cnt\n" if $debug;
    }

    if (@done){
	print STDOUT "\n[INFO] AIMS status for successfully configured hosts:\n[INFO]\n";
	open(AIMS, "/usr/bin/aims2client showhost ".join(",",map { gethostbyname($_ . "-gigeth") ? $_ . "-gigeth" : $_ } @done)." |");
	while (<AIMS>){
	    print STDOUT "[INFO]   $_";
	}
	close AIMS;
    }
    
    return @done;
}

################################################################################################
#
# CreateVM(): Request new hosts from CVI
#
sub CreateVM($@){
    my ($href,@host) = @_;
    my %opts = %$href;
    print Dumper(\%opts) if $debug;

    my $proxy = "https://vmm.cern.ch/vmmgtsvc/service.asmx";

    sub SOAP::Transport::HTTP::Client::get_basic_credentials{
	return "cern\\$user_credentials{username}" => $user_credentials{password};
    }
    my $soapRequest = SOAP::Lite
	-> uri('https://vmm.cern.ch/vmmgtsvc/')
	-> on_fault(sub{my ($soap,$res) = @_;
			print STDERR "[ERROR] Fatal SOAP error: ".(ref $res ? $res->faultstring : $soap->transport->status)."\n";
			exit 1;
		    })
	-> default_ns('VmMgtSvc')
	-> xmlschema('http://www.w3.org/2001/XMLSchema')
	-> on_action( sub { sprintf '"VmMgtSvc/%s"', $_[1] } )
	-> proxy($proxy, timeout => 3600)
	;

    #
    # Verify template
    #
    if (defined $opts{template}){
	my $call = $soapRequest->TemplateGetAll();#exit;
	if ($call->fault) {
	    print STDERR "[ERROR] Failure to retrieve \"TemplateGetAll\" information: " . $call->faultstring . "\n";
	    exit -1;
	}else{
	    my $result = $call->result;
	    my @template = map {$$_{Name}} @{$$result{Template}};
	    if (not grep {$_ eq $opts{template}} @template){
		print "Unknown template \"$opts{template}\" specified. Available Templates:\n";
		map {print "   *  $_\n"} sort @template;
		exit 1;
	    }
	}
    }else{
	$opts{template} = "linuxPXE";
    }

    #
    # Verify hostgroup
    #
    if (defined $opts{hostgroup}){
	my $call = $soapRequest->HostGroupGetAllForUser();#exit;
	if ($call->fault) {
	    print STDERR "[ERROR] Failure to retrieve \"HostGroupGetAllForUser\" information: " . $call->faultstring . "\n";
	    exit -1;
	}else{
	    my $result = $call->result;
	    my @hostgroup = ( ref($result->{"anyType"}) eq "ARRAY" ? @{$result->{"anyType"}} : $result->{"anyType"} );
	    if (not grep {$_ eq $opts{hostgroup}} @hostgroup and not gethostbyname($opts{hostgroup})){
		print "Unknown Host or Host Group \"$opts{hostgroup}\" specified. Available Host Groups:\n";
		map {print "   *  $_\n"} sort @hostgroup;
		exit 1;
	    }
	}
    }else{
	$opts{hostgroup} = "-- Central Service --";
    }

    #
    # Administrivia
    #
    $opts{vmservice} ||= "";
    $opts{owner}     ||= $user_credentials{username};

    print Dumper(\%opts) if $debug;#exit;

    #
    # Create the VMs
    #
    for my $host (@host){
	
	if ($dryrun){
	    print STDOUT "[INFO] Dryrun: request for \"$host\" deliberately not submitted\n";
	    next;
	}
 
	my $call = $soapRequest->
	    call('VMCreateRequest',
		 SOAP::Data->name('VMName'        )->value($host),                          # <VMName>string</VMName>
		 SOAP::Data->name('Description'   )->value($opts{comment}),                 # <Description>string</Description>
		 SOAP::Data->name('TemplateName'  )->value($opts{template}),                # <TemplateName>string</TemplateName>
		 SOAP::Data->name('MainUser'      )->value($opts{owner}),                   # <MainUser>string</MainUser>
		 SOAP::Data->name('Owner'         )->value($opts{owner}),                   # <Owner>string</Owner>
		 SOAP::Data->name('VMHostOrGroup' )->value($opts{hostgroup}),               # <VMHost>string</VMHost>
		 SOAP::Data->name('VMService'     )->value($opts{vmservice}),               # <VMService>string</VMService>
		 SOAP::Data->name('CPUCount'      )->value($opts{"cpu-count"}),             # <CPUCount>int</CPUCount>
		 SOAP::Data->name('MemorySizeGB'  )->value($opts{memory})->type('float'),   # <MemorySizeGB>float</MemorySizeGB>
		 SOAP::Data->name('SysDiskSizeGB' )->value($opts{disksize}),                # <SysDiskSizeGB>int</SysDiskSizeGB>
		 SOAP::Data->name('ExpirationDate')->value($opts{"expiration-date"})->type('dateTime'), # <ExpirationDate>string</ExpirationDate>
            );
	if ($call->fault) {
	    print STDERR "[ERROR] Failure to execute \"VMCreateRequest\" for VM \"$host\": " . $call->faultstring . "\n";
	    #exit -1;
	}else{
	    my $result = $call->result;
	    if ($result){
		print STDERR "[WARN] Creation request for VM \"$host\" failed: $result\n";
	    }else{
		print STDOUT "[INFO] Creation request for VM \"$host\" successfully submitted\n";
	    }
	}
	
    }


}


################################################################################################
#
# ShowConfig(): display configuration information
#
sub ShowConfig($){
    my $href = shift @_;
    my %config = %$href;

    #print Dumper(\%config);
    for my $attr (sort keys %config){
	printf STDOUT "* %15s : ",$attr;
	my @values = sort values %{$config{$attr}};
	my $cnt = 0;
	while (my @tmp = splice(@values,0,5)){
	    last if not @tmp;
	    print STDOUT " "x20 if $cnt > 0;
	    map {printf "%-30s ", /\s/ ? "\"$_\"" : $_} @tmp;
	    print "\n";
	    $cnt++
	}
	print "\n";
	#print STDOUT "Allowed values : " . join(", ",map {"\"$_\""} @values)."\n\n";
    }
    return 0;
}

################################################################################################
#
# HandleOptions(): parse user options
#
sub HandleOptions(){

    $action = shift @ARGV;

    my %options = (addhost     => [qw(operatingsystem=s  architecture=s  hostgroup=s  environment=s  model=s  owner=s  comment=s  domain=s ptable=s medium=s)],
		   updatehost  => [qw(operatingsystem=s  architecture=s  hostgroup=s  environment=s  model=s  owner=s  comment=s  domain=s ptable=s medium=s network)],
		   showhost    => [qw(operatingsystem=s@ architecture=s@ hostgroup=s@ environment=s@ model=s@ owner=s@ comment=s@ all regexp)],
		   delhost     => [qw()],
		   installhost => [qw()],
		   chkhost     => [qw()],
		   showconfig  => [qw()],
		   createvm    => [qw(expiration-date=s cpu-count=f memory=f disksize=f comment=s owner=s hostgroup=s template=s)],
    );
    HelpMessage("Mandatory parameter [".join("|",sort keys %options)."] missing") unless exists $options{$action};

    my %opts = (debug   => \$debug,
		dryrun  => \$dryrun,
		verbose => \$verbose);
 
    my $rc = Getopt::Long::GetOptions(\%opts,
				      (map {$_ => \$opts{(split(/=/,$_))[0]}} @{$options{$action}}),
				      "debug","dryrun","verbose",
				      "cern-user=s" => \$user_credentials{username},
	);
    HelpMessage("Could not parse options.") if not $rc;
    $verbose = 1 if $debug;
    map {delete $opts{$_} unless defined $opts{$_}} keys %opts;

    if ($action eq "addhost"){
        my @err = ();
	map {push(@err,$_) unless exists $opts{$_}} qw(operatingsystem architecture hostgroup model owner);
	if (@err){
	    map {print STDERR "[ERROR] Action \"$action\" requires mandatory option \"$_\"\n"} @err;
	    exit 1;
	}
	$opts{domain}      ||= "cern.ch";
	$opts{ptable}      ||= "RedHat default";
	$opts{environment} ||= "production";
	$opts{network}       = 1;
    }elsif ($action eq "updatehost"){
	#$opts{medium} = $opts{operatingsystem};
	#print Dumper(\%opts);
	map {delete $opts{$_} unless defined $opts{$_}} keys %opts;
	#print Dumper(\%opts);exit;

	my $cnt = 0;
	my @opt = qw(operatingsystem architecture hostgroup model owner ptable comment network environment);
	map {$cnt++ if defined $opts{$_}} @opt;
	if ($cnt == 0){
	    print STDERR "[ERROR] Action \"$action\" requires at least one of the options \"--". join("\", \"--",@opt)."\"\n";
	    exit 1;
	}
    }elsif ($action eq "showhost"){
	$opts{all} = 1 if $opts{regexp} and not @ARGV;
	if (not @ARGV and not $opts{all}){
	    print STDERR "[ERROR] Action \"$action\" requires either option \"--all\" or a list of hostnames.\n";
	    exit 1;
	}
    }elsif ($action eq "createvm"){
	my @host = @ARGV;
	if (not @host){
	    print STDERR "[ERROR] No hostname(s) given...\n";
	    exit 1;
	}
        my @err = ();
	map {push(@err,"Host \"$_\" already exists in DNS") if gethostbyname($_)} @host;
	if (@err){
	    map {print STDERR "[ERROR] $_\n"} @err;
	    exit 1;
	}

        # @err = ();
	# map {push(@err,"Action \"$action\" requires mandatory option \"$_\"") unless exists $opts{$_}} qw(expiration-date);
	# if (@err){
	#     map {print STDERR "[ERROR] $_\n"} @err;
	#     exit 1;
	# }
	if (not exists $opts{"expiration-date"}){
	    my $dt = DateTime->now + DateTime::Duration->new(months => 6);
	    $opts{"expiration-date"} = $dt->ymd("-");
	}else{
	    if (not ParseDate($opts{"expiration-date"})){
		print STDERR "[ERROR] Cannot parse \"".$opts{"expiration-date"}."\"\n";
		exit 1;
	    }
	}
	my $cmp = Date_Cmp($opts{"expiration-date"},ParseDate("today")) || 0;
	if ($cmp < 0){
	    print STDERR "[ERROR] expiration date \"".$opts{"expiration-date"}."\" in the past\n";
	    exit 1;
	}
	$opts{"cpu-count"} ||=  2;
	$opts{memory}      ||=  2;
	$opts{disksize}    ||= 40;
	$opts{comment}     ||= "(no description)";
	
    }
				      
    return $action,%opts;
}

################################################################################################
#
# GetUserCredentials(): return username/password combination of the cern-account to be used
#                       in subsequent calls to Landb etc.
#

sub GetUserCredentials($){

    use Net::Netrc;
    use Term::ReadKey;

    my $username = shift @_;
    my $password = undef;

    my $mach = undef;
    if (defined $username){
	$mach = Net::Netrc->lookup("network.cern.ch",$username);
    }

    if ($mach){
	$password = $mach->password;
    }else{
	if (not defined $username){
	    print STDOUT "Please give the CERN username/password combination to query LANdb, talk to Foreman, etc: \n";
	    print STDOUT "   - username : ";
	    chomp($username = <STDIN>);
	    if (not defined $username){
		print STDERR "Failed to read a username, exiting\n";
		return ();
	    }
	}else{
	    print STDOUT "Please give the password for CERN account \"$username\" to query LANdb, talk to Foreman, etc: \n";
	}
	print STDOUT "   - password : ";
	ReadMode("noecho",);
	chomp($password = <STDIN>);
	ReadMode("normal");
	print "\n";
	if (not defined $password){
	    print STDERR "failed to read a password, exiting\n";
	    return ();
	}
    }

    return ($username,$password);
}

################################################################################################
#
# HelpMessage(): displays user help
#

sub HelpMessage(;$){
    map {print STDOUT "$_\n"} @_;
    use File::Basename;
    print STDOUT"\nRun \"man ".basename $0."\" for more information.\n";
    #use Pod::Usage;
    #pod2usage(-verbose=> 2);
    exit 0;

}

__END__

=pod

=head1 NAME

ai-foreman-cli - Utility to update, retrieve, delete information for the Foreman setup of the Agile Infrastructure project

=head1 DESCRIPTION

ai-foreman-cli is a command line interface to the Foreman setup of the Agile Infrastructure project.
It should be used to displaying information about hosts, to delete or update that information.

=head1 SYNOPSIS

=over 4

ai-foreman-cli [--help]

ai-foreman-cli ACTION [OPTIONS] [HOSTNAME]

=back

=head1 ACTIONS

=over 4

=item B<showhost> HOSTNAME(S)

Display information about host(s) HOSTNAME(S)

=item B<addhost> [OPTIONS] HOSTNAME ...

Add hosts to Foreman.

Note: Network information (IP and MAC addresses etc.) is retrieved from Landb

=item B<delhost> [OPTIONS] HOSTNAME ...

Delete hosts

=item B<updatehost> [OPTIONS] HOSTNAME ...

Update information for hosts

=item B<installhost> [OPTIONS] HOSTNAME ...

Generates kickstart files for hosts, and upload them to AIMS

=item B<chkhost> [OPTIONS] HOSTNAME ...

Performs some basic consistency checks on the information about hosts

=item B<createvm> [OPTIONS] HOSTNAME ...

Create Virtual Machines in the CVI service

=item B<showconfig> [OPTIONS]

Show the Foreman configuration details 

=item B<help>

Display this help

=back

=head1 OPTIONS

Action specific options

=over 4 

=item B<addhost>

=over 8

=item B<--operatingssystem> NAME

=item B<--architecture> NAME

=item B<--hostgroup> NAME

=item B<--environment> NAME

default: "production"

=item B<--model> NAME

=item B<--owner> NAME

Can be CERN account or E-group.

=item B<--comment> COMMENT

default: empty

=item B<--domain> NAME

default: "cern.ch"

=item B<--ptable> NAME

default: "RedHat default"

=back

=back

=over 4 

=item B<updatehost>

=over 8

=item B<--operatingsystem> NAME

=item B<--architecture> NAME

=item B<--hostgroup> NAME

=item B<--environment> NAME

=item B<--model> NAME

=item B<--owner> NAME

Can be CERN account or E-group.

=item B<--comment> COMMENT

=item B<--network>

IP and MAC addresses are retrieved from Landb

=back

=item B<showhost>

=over 8

=item B<--all>

Display information for all hosts known to Foreman

Filtering options:

=over 12

=item B<--model> NAME

=item B<--owner> NAME

=item B<--operatingsystem> NAME 

=item B<--architecture> NAME 

=item B<--hostgroup> NAME 

=item B<--environment> NAME 

=item B<--model> NAME 

=item B<--owner> NAME 

=item B<--comment> NAME 

=item B<--regexp>

Interpret filtering options as regular expressions

=back

=back

=back

=over 4 

=item B<createvm>

=over 8

=item B<--expiration-date> YYYY-MM-DD

Default: 6 months.
Can be modified afterwards using CVI interface

=item B<--template> NAME

Default: linuxPXE

=item B<--cpu-count> NUMBER

Default: 2

=item B<--memory> NUMBER

Default: 2 [GB]

=item B<--disksize> NUMBER

Default: 40 [GB]

=item B<--comment> COMMENT

=item B<--owner> NAME

Can be CERN account or E-group.
Default: you.

=item B<--hostgroup> NAME

CVI hostgroup in which the VM will be created

=back

=back

=back

General options

=over 4

=item B<--cern-user> USERNAME

CERN account to be used for LANdb lookups and Foreman access

=item B<--help>

Shows this help description

=item B<--verbose>

Be verbose

=item B<--debug>

Print debug output

=item B<--dryrun>

For the installhost action: do not upload to AIMS

=back

All options can be abbreviated to shortest distinctive length. Single minus preceding option name may be used instead of double one.

=head1 EXAMPLES

=over 4

ai-foreman-cli showhost janvm01

ai-foreman-cli delhost janvm01

ai-foreman-cli addhost janvm01 --cern-account heuer --oper "SLC 6" --model e4_09_21 --arch x86_64 --hostgroup base --owner jveldik

ai-foreman-cli updatehost janvm01 --comment "no comment"

=back

=head1 AUTHOR

Jan van Eldik <Jan.van.Eldik@cern.ch>

=head1 KNOWN BUGS

=cut
