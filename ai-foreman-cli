#! /usr/bin/perl -w

# To-do:

use strict;
use diagnostics;
use POSIX;
use Getopt::Long;
use Data::Dumper;
use SOAP::Lite;# +trace => 'debug';
use File::Basename;
use LWP;
use JSON;
use Socket;
use NetAddr::IP;

$Data::Dumper::Sortkeys = 1;

sub ForemanConfig($$);
sub LandbHostInfo(@);
sub ShowHost($@);
sub ShowConfig($);
sub DeleteHost($@);
sub ChkHost(@);
sub UpdateHost($@);
sub InstallHost(@);
sub SetupAims($);
sub GetUserCredentials($);
sub HelpMessage();
sub HandleOptions();

HelpMessage() if not @ARGV;

my $debug = my $verbose = my $dryrun = 0;
my %user_credentials = ();

my ($action,%opts) = HandleOptions();

#print "\@ARGV @ARGV\n";

#print Dumper(\%opts);#exit;

my @host = @ARGV;
if (not @host and not ($action eq "showhost" or $action eq "showconfig")){
    print STDERR "[ERROR] No hostname(s) given...\n";;
    exit 1;
}

map {s/.cern.ch//; $_ = lc} @host;  # strip domain name, change to lower case

#
# Get user credentials
#
($user_credentials{username},$user_credentials{password}) = GetUserCredentials($user_credentials{username});

#
# Connect to Foreman
#
my $url         = "https://punch.cern.ch";
my $netlocation = "punch.cern.ch:443";
my $realm       = "Application";
my $browser     = LWP::UserAgent->new;
$browser->credentials($netlocation,$realm,$user_credentials{username} => $user_credentials{password});

#
# Does the user have administrator privileges?
#
my $request = HTTP::Request->new("GET","$url/users");
$request->header("Content-Type" => "application/json");
my $response = $browser->request($request);
if (not $response->is_success){
    print STDERR "[ERROR] Could not retrieve list of users from Foreman: \"".$response->status_line."\"\n";
    exit 1;
}
for (grep { ${$$_{user}}{login} eq $user_credentials{username} } @{from_json($response->content)}){
    my %tmp = %$_;
    $user_credentials{administrator} = defined ${$tmp{user}}{admin} ? 1 : 0;
}

if (not $user_credentials{administrator}){
    print STDERR "[ERROR] This tool currently requires admin privileges on Foreman.\n";
    exit 1;
}

#
# Easy things first.
#
if ($action eq "delhost"){
    DeleteHost(\%opts,@host);
    exit 0;
}elsif ($action eq "chkhost"){
    ChkHost(@host);
    exit 0;
}

#
# Resolve Foreman ID's, update host data.
#
my %fmdata = ForemanConfig($browser,$url);

#
# more easy things.
#
if ($action eq "showhost"){
    ShowHost(\%opts,@host);
    exit 0;
}elsif ($action eq "installhost"){
    InstallHost(@host);
    exit 0;
}elsif ($action eq "showconfig"){
    ShowConfig(\%fmdata);
    exit 0;
}

#
# Do the user options have correct values?
#
my @err = ();
for my $attr (qw(architecture model operatingsystem hostgroup environment owner domain ptable)){
    next if not defined $opts{$attr};
    next if grep {$opts{$attr} eq $_} values %{$fmdata{$attr}};
    push(@err,"[ERROR] Option \"--$attr\" has unknown value \"$opts{$attr}\". Valid values: ".join(", ",map {"\"$_\""} sort values %{$fmdata{$attr}})."\n");
}
if (@err){
    map {print STDERR $_} @err;
    exit 1;
}

#
# Do the real work
#
if ($action eq "addhost" or $action eq "updatehost"){
    my @done = UpdateHost({%opts,("action" => $action)},@host);
    if (@done){
	print STDOUT "\n[INFO] Summary:\n\n";
	ShowHost(undef,@done);
	print STDOUT "\n";
    }
}

exit 0;

sub ShowHost($@){
    my ($href,@host) = @_;
    my %opt = defined $href ? %$href : ();
    if ($opt{all} or ($opt{hostname} and $opt{regexp})){
	my $request = HTTP::Request->new("GET","$url/hosts");
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if (not $response->is_success){
	    print STDERR "[ERROR] Could not retrieve list of hosts from Foreman...\n";
	    return -1;
	}
	if ($opt{all}){
	    @host = sort @{from_json($response->content)};	
	    map {s/.cern.ch//; $_ = lc} @host;  # strip domain name, change to lower case
	}elsif ($opt{hostname} and $opt{regexp}){
	    my %host = ();
	    my @list = @{from_json($response->content)};
	    for my $hostname (@{$opt{hostname}}){
		map {s/.cern.ch//;$host{$_}++ if /$hostname/i} @list;
	    }
	    push(@host,keys %host);
	}
	#print STDOUT "[INFO] Retrieving information for ".scalar(@host)." machines\n";
    }elsif ($opt{hostname}){
	push(@host,map {s/.cern.ch//; $_ = lc} @{$opt{hostname}});
    }
    #print Dumper(\%opt); print "\@host = \"@host\"\n";
    #exit;

    my $FORMAT = " %-15s %-30s %-15s %-15s %-6s  %-25s %-10s %s\n";
    #
    # Are the hosts known to Foreman?
    #
    my @out = ();
    for my $host (sort @host){
	my $request = HTTP::Request->new("GET","$url/hosts/$host" . ($host !~ /\./ ? ".cern.ch" : ""));
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if (not $response->is_success){
	    print STDERR "[ERROR] Host \"$host\" is unknown to Foreman...\n";
	    #print Dumper($response);
	    next;
	}
	my %data = %{from_json($response->content)};
	%data = %{$data{host}};
	#print Dumper(\%data);exit;
	#printf "%15s %-15s %15s %-15s %15s\n",$host,map {$data{$_} || "oops..."} qw(environment_id owner_id ip managed) if $debug;

	# make "Comment" field fit to print
	$data{comment} ||= "";
	$data{comment} =~ s/\n//g;
	$data{comment} =~ s/\s+/ /g;

	$data{operatingsystem} = $fmdata{operatingsystem}{ $data{operatingsystem_id} || -1 } || "";
	$data{architecture}    = $fmdata{architecture}   { $data{architecture_id}    || -1 } || "";
	$data{hostgroup}       = $fmdata{hostgroup}      { $data{hostgroup_id}       || -1 } || "";
	$data{environment}     = $fmdata{environment}    { $data{environment_id}     || -1 } || "";
	$data{owner}           = $fmdata{owner}          { $data{owner_id}           || -1 } || "";
	$data{model}           = $fmdata{model}          { $data{model_id}           || -1 } || "";

	# apply filters
	my $ok = 1;
	for my $attribute (grep {exists $opt{$_}} qw(operatingsystem architecture hostgroup environment owner model comment)){
	    #print "OK $host \$attribute = \"$attribute\" @{$opt{$attribute}}\n";
	    if ($opt{regexp}){
		$ok = 0 unless grep {$data{$attribute} =~ /$_/i} @{$opt{$attribute}};
	    }else{
		$ok = 0 unless grep {lc($_) eq lc($data{$attribute})} @{$opt{$attribute}};
	    }
	    last if not $ok;
	}
	next if not $ok;

	#print Dumper(\%fmdata);
	#
	push(@out,sprintf $FORMAT, $host, map {$data{$_}} qw(hostgroup environment operatingsystem architecture model owner comment));
    }

    if (@out){
	printf STDOUT $FORMAT,qw(Hostname Hostgroup Environment OS Arch Hardware-model Owner Comment);
	printf STDOUT $FORMAT,qw(======== ========= =========== == ==== ============== ===== =======);
	map {print STDOUT $_} @out;
	return 0;
    }else{
	print STDERR "[ERROR] No machines found\n";
	return -1;
    }

}

sub DeleteHost($@){
    my ($href,@host) = @_;
    my %opt = %$href;
    #
    # Are the hosts known to Foreman?
    #
    my @err = ();
    for my $host (sort @host){
	my $request = HTTP::Request->new("DELETE","$url/hosts/$host.cern.ch");
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if ($response->is_success){
	    print STDOUT "[INFO] Deleted \"$host\" from Foreman.\n";
	}else{
	    push(@err,$host);
	}
    }
    if (@err){
	print STDERR "[ERROR] Could not delete host(s) \"".join("\" - \"",@err). "\" from Foreman.\n";
	return 1;
    }
    return 0;
}

sub ChkHost(@){
    my @host = @_;

    #
    # Are the hosts known to Foreman?
    #
    my @err = my %todo = ();
    for my $host (@host){
     	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
     	$request->header("Content-Type" => "application/json");
     	my $response = $browser->request($request);
	if (not $response->is_success){
     	    print STDERR "[ERROR] No host \"$host\" known to Foreman\n";
      	    next;
	}
	#
	my @error = ();
     	my %data = %{${from_json($response->content)}{host}};
	#print Dumper(\%data);exit;
	
	# IP address?
	my $iaddr = gethostbyname($host);
	die "aargh..." if not defined $iaddr;
	$iaddr = inet_ntoa($iaddr);
	push(@error,"$host: IP address in Foreman is $data{ip}, but DNS says $iaddr") if $data{ip} ne $iaddr;
	
	# IPMI ip-address?
	if (exists $data{sp_ip} and $data{sp_name}){
	    my $iaddr = gethostbyname($data{sp_name});
	    die "aargh..." if not defined $iaddr;
	    $iaddr = inet_ntoa($iaddr);
	    push(@error,"$data{sp_name}: IP address in Foreman is $data{sp_ip}, but DNS says $iaddr") if $data{sp_ip} ne $iaddr;
	}

	# print result
	if (@error){
	    map {print "[$host] $_\n"} @error;
	}else{
	    print "[$host] OK\n";
	}
    }
    return;
}

sub InstallHost(@){
    my @host = @_;

    #
    # Show the hosts
    #
    print STDOUT "[INFO] Installation requested for" . (scalar(@host) == 1 ? "" : " " .scalar(@host) ." machines" ) . ":\n\n";
    ShowHost(undef,@host);
    print STDOUT "\n";

    #
    # Are the hosts known to Foreman?
    #
    my @err = my %todo = ();
    for my $host (@host){
     	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
     	$request->header("Content-Type" => "application/json");
     	my $response = $browser->request($request);
	push(@err,$host) unless $response->is_success;
	next if @err;
	#
     	my %data = %{from_json($response->content)};
     	#print Dumper(\%data);exit;
	$todo{$host}{operatingsystem} = $fmdata{operatingsystem}{$data{host}{operatingsystem_id}};
	$todo{$host}{architecture}    = $fmdata{architecture}   {$data{host}{architecture_id}   };
	$todo{$host}{model}           = $fmdata{model}          {$data{host}{model_id}          };
	$todo{$host}{hostname}        = $host;
    }
    if (@err){
     	print STDERR "[ERROR] Host(s) \"".join("\" - \"",@err). "\" unknown to Foreman, exiting...\n";
     	exit 1;
    }

    #
    # Delete certs
    #
    @err = ();
    for my $host (keys %todo){
	my $request = HTTP::Request->new("DELETE","$url/smart_proxies/2-punch-cern-ch/puppetca/$host.cern.ch"); # XXX to-do: replace hardcoded URL by sthg smart :)
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if (not $response->is_success){
	    push(@err,$host);
	    print "[ERROR] ".$response->status_line."\n" if $debug;
	}
	#print Dumper(\$response);exit;
    }
    if (@err){
	print STDERR "[WARN] Could not revoke certificate for host(s) \"".join("\" - \"",@err). "\" from Puppet Certificate Authority...\n";
	#exit 1;
    }
    
    #
    # Prepare Kickstart file
    #
    for my $host (sort keys %todo){

	my %data = (USER => $user_credentials{username});

	if (gethostbyname("${host}-gigeth")){
	    print "[INFO] Getting LANdb info for host \"$host\", patience please...\n";
	    my %landb = LandbHostInfo($host);
	    #print Dumper(\%landb);
	    if (not %landb){
		print "[WARNING] Could not get Landb info for \$host\", skipping it...\n";
		next;
	    }
	    $data{NETWORK}  = "\n#\n# - onboot=yes for the 10GB interface, specify hostname";
	    $data{NETWORK} .= "\n# - onboot=no  for the  1GB interface, do *not* specify a hostname!\n#\n\n";
	    for my $name (keys %{$landb{$host}{Interfaces}}){
		my $mac = $landb{$host}{Interfaces}{$name}{HardwareAddress};
		if ($name eq $host){
		    $data{NETWORK} .= "network --bootproto=dhcp --device=$mac --onboot=yes --hostname $host.cern.ch\n";
		} elsif ($name eq "${host}-gigeth"){
		    $data{NETWORK} .= "network --bootproto=dhcp --device=$mac --onboot=no\n";
		}
	    }
	    #print $data{NETWORK};exit;
	    $todo{$host}{hostname} .= "-gigeth";
	#}else{
	#    $data{NETWORK} = "network --bootproto=dhcp --device=eth0 --hostname $host.cern.ch";
	#    $todo{$host}{hostname} = $host;
	}
	
	my $model = $data{HWMODEL} = $todo{$host}{model};

	# if (uc($data{HWMODEL}) eq "HYPER-V VIRTUAL MACHINE" and $todo{$host}{operatingsystem} =~ /^(SLC|RedHat) 5\./){
	#     $data{FIRST_DRIVE} = "hda";
	# } else {
	#     $data{FIRST_DRIVE} = "sda";
	# }

	# Get the KS file from Foreman
	my $iaddr = gethostbyname($host);
	die "aargh..." if not defined $iaddr;
	$iaddr = inet_ntoa($iaddr);
	my $ksfile = "$url/unattended/provision?spoof=$iaddr";
	my $request = HTTP::Request->new("GET",$ksfile);
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if (not $response->is_success){
	    print STDERR "[ERROR] Failed to retrieve a Kickstart file \"$ksfile\":\n";
	    print STDERR "[ERROR]   ".$response->content."\n";
	    #print STDERR Dumper($response)."AARGH! $url/unattended/provision?spoof=$iaddr\n";
	    exit;
	}
	my $template = $response->content;

	use Text::Template;
	my $tpl = new Text::Template(TYPE    => "STRING",
				     UNTAINT => 1,
				     SOURCE  => $template) or die "Couldn't construct template: $Text::Template::ERROR";

	my $result = $tpl->fill_in(HASH => \%data);
	if (not defined $result) {
	    print STDERR "Couldn't fill in template: $Text::Template::ERROR\n";
	    next;
	}
    
	$todo{$host}{ksfile} = POSIX::tmpnam();
	if (not open(F,"> $todo{$host}{ksfile}")){
	    print STDERR "[ERROR] Could not open \"$todo{$host}{ksfile}\" for writing: $!\n";
	    next;
	}
	print F $result;
	#print $result if $debug;
	close F;
    
	# Console options
	if (uc($model) eq "HYPER-V VIRTUAL MACHINE"){
	    $todo{$host}{console} = "";
	}elsif (uc($model) eq "AC_11_30"){
	    $todo{$host}{console} = "console=tty0";
	}else{
	    $todo{$host}{console} = "console=tty0 console=ttyS2,9600n8";
	}

    }
    #print Dumper(\%todo);exit;

    #
    # Upload to AIMS
    #
    @host = SetupAims(\%todo);
    if (not @host){
	print STDERR "[ERROR] Upload to AIMS failed, exiting...\n";
	exit 1;
    }

    #my $mess1 = join("\n",map {"      ssh root\@punch puppetca --clean $_.cern.ch"} @host);
    my $mess2 = join("\n",map {"      ssh root\@$_ shutdown -r now"} @host);
    my $mess3 = "      ssh lxadm remote-power-control reset ". join(",",@host)."\n";
    #my $mess3 = join("\n",map {"      ssh lxadm remote-power-control reset $_"} @host);
    my $mess4 = join("\n",map {"      ssh lxadm connect2console.sh $_"} @host);
    my $mess5 = undef;
    map {$mess5 .= "      aims2 pxeoff $_-gigeth\n" if gethostbyname($_ . "-gigeth")} @host;

    print <<EOMESS;

-- Reboot the host to start the installation:

$mess2

   or

$mess3

-- To see installation in progress:

$mess4

EOMESS

    if ($mess5){
	print <<EOMESS;

-- IMPORTANT NOTE FOR "*-GIGETH" MACHINES: once the installation is underway, run 

$mess5
    to break out on an install loop
EOMESS
    }

    return 0;
}

sub UpdateHost($@){
    my ($href,@host) = @_;
    my %opt = %$href;
    print Dumper(\%opt) if $debug;

    my $action = $opt{action};
    delete $opt{action};
    if (not grep {$_ eq $action} qw(addhost updatehost)){
	print STDERR "[ERROR] UpdateHost: unsupported action \"$action\" specified\n";
	return undef;
    }

    #print "@host\n";

    #
    # get network data
    #
    my %landb = my %subnet = ();
    if ($opt{network}){
	%landb = LandbHostInfo(@host);
	print Dumper(\%landb) if $debug;
	for (@{from_json($browser->get("$url/subnets?format=json")->content)}){
	    my %tmp = %{$$_{subnet}};
	    %{$subnet{$tmp{id}}} = (network => $tmp{network}, mask => $tmp{mask});
	}
	#print Dumper(\%subnet);#exit;
    }

    #
    # installation media
    #
    if (defined $opt{operatingsystem} and not defined $opt{medium}){
	if ($opt{operatingsystem} =~ /^SLC/){
	    $opt{medium} = "SLC";
	}elsif ($opt{operatingsystem} =~ /^RedHat 6/){
	    $opt{medium} = "RedHat 6";
	}elsif ($opt{operatingsystem} =~ /^Fedora/){
	    $opt{medium} = "Fedora Mirror";
	}else{
	    print STDERR "[ERROR] UpdateHost: no medium defined for operating system \"$opt{operatingsystem}\"\n";
	    return undef;
	}
    }
    print Dumper(\%opt) if $debug;
  
    #
    # build the data structure to be sent to Foreman
    #
    my %data = my @err = ();

    for my $attr (keys %opt){
	for (keys %{$fmdata{$attr}}){
	    if (lc(${$fmdata{$attr}}{$_}) eq lc($opt{$attr})){
		$data{"${attr}_id"} = $_;
		last;
	    }
	}
	
	push(@err,"Could not find Foreman identifier for attribute \"$attr\" with requested value \"$opt{$attr}\"") if not exists $data{"${attr}_id"} and %{$fmdata{$attr}};
    }
    if (@err){
	map {print STDERR "[ERROR] $_\n"} sort @err;
	return undef;
    }

    $data{comment} = exists $opt{comment} ? $opt{comment} : undef;
    $data{owner_type} = "User" if exists $data{owner_id}; # to successfully set the owner (Bug http://theforeman.org/issues/1370 )

    #
    #
    #
    print Dumper(\%fmdata) if $debug;#exit;
    my @done = ();
    for my $host (sort @host){
	my $request = HTTP::Request->new("GET","$url/hosts/$host.cern.ch");
	$request->header("Content-Type" => "application/json");
	my $response = $browser->request($request);
	if ($action eq "addhost" and $response->is_success){
	    print STDERR "[WARN] Ignoring existing host \"$host\".\n";
	    next;
	}elsif ($action eq "updatehost" and not $response->is_success){
	    print STDERR "[WARN] Ignoring non-existent host \"$host\".\n";
	    next;
	}
	print STDOUT "[VERB] " . ($action eq "addhost" ? "Adding" : "Updating") . " \"$host\"\n" if $verbose;

	#
	# Network info
	#
	if ($opt{network}){
	    my %network = ();
	    for my $interface (keys %{$landb{$host}{Interfaces}}){
		next unless ($interface eq $host or $interface eq "${host}-ipmi");
		my $ipaddr = $landb{$host}{Interfaces}{$interface}{IPAddress};
		my $subnet_id = undef;
		my $ip = NetAddr::IP->new($ipaddr);
		for my $id (keys %subnet){
		    if ($ip->within(NetAddr::IP->new($subnet{$id}{network},$subnet{$id}{mask}))){
			$subnet_id = $id;
			last;
		    }
		}
		if (not defined $subnet_id){
		    print STDERR "[ERROR] Could not get subnet_id for host $interface, exiting!\n";
		    exit 1;
		}

		my $prefix = $interface eq $host ? "" : "sp_"; # Ordinary interface, or IPMI?
		$network{$prefix . "name"}      = $interface;
		$network{$prefix . "mac"}       = $landb{$host}{Interfaces}{$interface}{HardwareAddress};
		$network{$prefix . "ip"}        = $ipaddr;
		$network{$prefix . "subnet_id"} = $subnet_id;
	    }
	    %data = (%data, %network);
	}

	#
	# Sanity checks
	#
        map {delete $data{$_} if not defined $data{$_}} keys %data;
	if (not %data and $action eq "updatehost"){
	    print STDERR "[ERROR] Nothing to update?!\n";
	    last;
	}
	print Dumper(\%data) if $debug;#exit;

	if ($opt{network} and not exists $data{name}){
	    print STDERR "[ERROR] Incomplete network information for host \"$host\", skipping it...\n";
	    next;
	}

	#
	# Action!
	#
     	$request = HTTP::Request->new($action eq "updatehost" ? ("PUT","$url/hosts/$host.cern.ch") : ("POST","$url/hosts") );
     	$request->header("Content-Type" => "application/json");
	print "[DEBUG] JSON: ".to_json({host => \%data})."\n" if $debug;
     	$request->content(to_json({host => \%data}));
	
     	$response = $browser->request($request);
	
     	if ($response->is_success){
	    print STDOUT "[INFO] Successfully " . ( $action eq "addhost" ? "added" : "updated" ) . " $host\n";
	    push(@done,$host);
	}else{
     	    print STDERR "[ERROR] Cannot " . ( $action eq "addhost" ? "add" : "update" ) . " \"$host\": " . $response->status_line . " :: " . $response->content ."\n";
     	}
    }

    return @done;
}

sub ForemanConfig($$){
    my ($browser,$url) = @_;
    my %config = ();

    # record ptable per OS
    my %ptable = my %medium = ();
    for (@{from_json($browser->get("$url/operatingsystems?format=json")->content)}){
	my %data = %{$$_{operatingsystem}};
	#print Dumper(\%data);#exit;
	for (@{$data{ptables}}){
	    my %pt = %{$$_{ptable}};
	    my $name = $pt{name};
	    $ptable{$name}++;
	}
	for (@{$data{media}}){
	    my %med = %{$$_{medium}};
	    my $name = $med{name};
	    $medium{$name}++;
	}
    }
    #print Dumper(\%medium);exit;

    # partition tables
    map {$config{ptable}         {$$_{ptable}         {id}} = $$_{ptable}         {name} } @{from_json($browser->get("$url/ptables?format=json")->content)};
    map {delete $config{ptable}{$_} unless exists $ptable{$config{ptable}{$_}}} keys %{$config{ptable}}; # remove ptables that are supported for unsupported OS-es :)

    # installation media
    map {$config{medium}         {$$_{medium}         {id}} = $$_{medium}         {name} } @{from_json($browser->get("$url/media?format=json")->content)};
    map {delete $config{medium}{$_} unless exists $medium{$config{medium}{$_}}} keys %{$config{medium}}; # remove media that are supported for unsupported OS-es :)

    map {$config{operatingsystem}{$$_{operatingsystem}{id}} = $$_{operatingsystem}{name} } @{from_json($browser->get("$url/operatingsystems?format=json")->content)};
    map {$config{architecture}   {$$_{architecture}   {id}} = $$_{architecture}   {name} } @{from_json($browser->get("$url/architectures?format=json")->content)};
    map {$config{model}          {$$_{model}          {id}} = $$_{model}          {name} } @{from_json($browser->get("$url/models?format=json")->content)};
    map {$config{hostgroup}      {$$_{hostgroup}      {id}} = $$_{hostgroup}      {label}} @{from_json($browser->get("$url/hostgroups?format=json")->content)};
    map {$config{environment}    {$$_{environment}    {id}} = $$_{environment}    {name} } @{from_json($browser->get("$url/environments?format=json")->content)};
    map {$config{owner}          {$$_{user}           {id}} = $$_{user}           {login}} @{from_json($browser->get("$url/users?format=json")->content)};
    map {$config{domain}         {$$_{domain}         {id}} = $$_{domain}         {name} } @{from_json($browser->get("$url/domains?format=json")->content)};
    #map {$config{subnet}         {$$_{subnet}         {id}} = $$_{subnet}         {name} } @{from_json($browser->get("$url/subnets?format=json")->content)};
    #%{$config{sp_subnet}} = %{$config{subnet}};

    #print Dumper(\@{from_json($browser->get("$url/operatingsystems?format=json")->content)});exit;
    #print Dumper(\%config);exit;
    return %config;
}

sub LandbHostInfo(@){
    my @device = @_;

    my $client = SOAP::Lite
	->uri('http://network.cern.ch/NetworkService')
	->xmlschema('http://www.w3.org/2001/XMLSchema')
	->proxy('https://network.cern.ch/sc/soap/soap.fcgi?v=4', keep_alive=>1);

    # Get Auth token
    my $call = $client->getAuthToken($user_credentials{username},$user_credentials{password},'NICE');
    
    my ($auth) = $call->result;
    if ($call->fault){
        print "ERROR: failed to authenticate to LANdb.\n";
        exit 1;
    }

    my $authHeader = SOAP::Header->name('Auth' => { "token" => $auth });

    my %landb = ();
    for my $device (@device){
	$call = $client->getDeviceInfo($authHeader,$device);
	
	my $bu = $call->result;
	if ($call->fault) {
	    print "[WARNING] Device \"$device\" not found in Landb, ignoring it...\n";
	    next;
	}
	#print Dumper($bu);exit;

	$landb{$device}{Model} = $bu->{Model};
	for (@{$bu->{Interfaces}}) {
	    #print Dumper(\$_);
	    my $Name = lc($_->{Name});
	    my $HardwareAddress = $_->{BoundInterfaceCard}->{HardwareAddress};
	    my $IPAddress = $_->{IPAddress};
	    if (defined $HardwareAddress){
		$HardwareAddress =~ s/\-/:/g;
		%{$landb{$device}{Interfaces}{$Name}} = (HardwareAddress => $HardwareAddress, IPAddress => $IPAddress);
	    }
	}
	if (not exists $landb{$device}{Interfaces}){
	    my $Name = lc($bu->{DeviceName});
	    for (@{$bu->{NetworkInterfaceCards}}) {
		my $HardwareAddress = $_->{HardwareAddress};
		my $IPAddress = $_->{IPAddress};
		if (defined $HardwareAddress){
		    $HardwareAddress =~ s/\-/:/g;
		    ${$landb{$device}{Interfaces}{$Name}}{HardwareAddress} = $HardwareAddress;
		}
	    }
	    for (@{$bu->{Interfaces}}) {
		if ($Name eq lc($_->{Name})){
		    ${$landb{$device}{Interfaces}{$Name}}{IPAddress} = $_->{IPAddress};
		}
	    }
	}
    }

    #print Dumper(\%landb);
    #exit;

    return %landb;
}
sub SetupAims($){
    my $href = shift @_;
    my %todo = %$href;
    my $rc = 0;
    #print Dumper(\%todo);exit;
    # Run "aims2 showimg all" to get list of all available AIMS images
    my %AimsImg = (
        "SLC 6.2"    => "SLC62_BETA",
        "SLC 6.1"    => "SLC61_BETA",
        "SLC 6"      => "SLC6X",
        "SLC 5.7"    => "SLC5X",
	#
        "RedHat 6.2" => "RHEL6_U2",
        "RedHat 6.1" => "RHEL6_U1",
        "RedHat 6"   => "RHEL6_U2",
        "RedHat 5.7" => "RHES_5_U7",
	#
	"Fedora 18"  => "FEDORA18",
	"Fedora 17"  => "FEDORA17",
	"Fedora 16"  => "FEDORA16",
	"Fedora 15"  => "FEDORA15",
        );

    for my $host (sort keys %todo){
	my $cnt = 0;
	my $kopts = "text network ks ksdevice=bootif latefcload";
	$kopts .= " $todo{$host}{console}" if $todo{$host}{console};
	$kopts .= " pcie_aspm=off" if $todo{$host}{model} eq "e4_09_21";
	if (not exists $AimsImg{$todo{$host}{operatingsystem}}){
	    print STDERR "[ERROR] No suitable AIMS target for Operating System \"$todo{$host}{operatingsystem}\" available. Probably a bug in the script you are running :)\n";
	    exit 1;
	}
	my $imgname = $AimsImg{$todo{$host}{operatingsystem}} . "_" . $todo{$host}{architecture};
	my $aims = "/usr/bin/aims2client addhost --hostname $todo{$host}{hostname} --kickstart $todo{$host}{ksfile} --kopts \"$kopts\" --pxe --name $imgname";
	while (1){
	    if ($dryrun){
		print "[DRYRUN] *Not* uploading Kickstart file for $host to AIMS\n";
		last;
	    }
	    print STDOUT "[INFO] Uploading Kickstart file for $host to AIMS\n";
	    print STDOUT "[VERB] Running \"$aims\"\n" if $verbose;
	    if (system("$aims 2>/dev/null 1>/dev/null") != 0){
		print STDERR "[ERROR] Upload to AIMS failed: $!\n";
		$rc++;
	    }
	    #
	    $aims = "/usr/bin/aims2client showhost $todo{$host}{hostname} --full";
	    print "[VERB] Running \"$aims\"\n" if $verbose;
	    open(F,"$aims |") or die "aagrh...";
	    my @output = <F>;
	    close F;
	    print "[DEBUG] \@output:\n @output\n" if $debug;
	    my $status = join(" ",grep /PXE status:/, @output);
	    print "[DEBUG] \$status $status\n" if $debug;
	    if ($status =~ /PXE status:\s+ON\s*\n/){
		last;
	    }else{
		if (++$cnt == 5){
		    print STDERR "[ERROR] Machine \"$host\" still not properly configured in AIMS, giving up...\n";
                    $rc++;
		    #unlink $todo{$host}{ksfile} unless $debug;
		    delete $todo{$host};
		    last;
		}
		print "[WARN] AIMS did not do its job for host $host, let's try again...\n";
		sleep 5;
	    }
	}
        #unlink $todo{$host}{ksfile} unless $debug;
    }
    # delete kickstart files
    map {unlink $todo{$_}{ksfile}} keys %todo unless $debug;
    return () unless %todo;

    print "[INFO] Verifying that AIMS is properly set up, patience please...\n";
    return 0 if $dryrun;
    $rc = 0;
    my @done = ();
    for my $host (sort keys %todo){
	my $cnt = 0;
	while (1){
	    #print "\$cnt = $cnt\n";
	    my $aims = "/usr/bin/aims2client showhost $todo{$host}{hostname} --full";
	    print "[VERB] Running \"$aims\"\n" if $verbose;
	    open(F,"$aims |") or die "aargh...";
	    my @output = <F>;
	    close F;
	    print "[DEBUG] \@output:\n @output\n" if $debug;
	    #my $status = join(" ",grep /PXE status:/, @output);
	    #print "[DEBUG] \$status $status\n" if $debug;
	    #if ($status !~ /PXE status:\s+ON\s*\n/){
	    #    print "AARGH! AIMS did not do its job for host $host! Complain && try again...!";
	    #    $cnt++;
	    #    last;
	    #}
	    my $sync = join(" ",grep /PXE boot synced:/, @output);
	    print "[DEBUG] \$sync    $sync\n" if $debug;
	    if ($sync =~ /PXE boot synced:\s+(\S+)\n/){
		my $status = $1;
		#print ">>> $status\n";
		if (grep {$_ eq $status} qw(YYY YYN YNY NYY)){
		    $cnt = 0;
		    push(@done,$host);
		    last;
		}
	    }
	    if ($cnt++ == 20){
		print "Machine \"$host\" still not properly configured in AIMS, giving up...\n";
		last;
	    }
	    print "[INFO] Sleeping 5 seconds...\n";
	    sleep 5;
	}
	$rc += $cnt;
    }

    if (@done){
	print STDOUT "[INFO] AIMS status for successfully configured hosts:\n[INFO]\n";
	open(AIMS, "/usr/bin/aims2client showhost ".join(",",map { gethostbyname($_ . "-gigeth") ? $_ . "-gigeth" : $_ } @done)." |");
	while(<AIMS>){
	    print STDOUT "[INFO]   $_";
	}
	close AIMS;
    }
    
    return @done;
}

sub ShowConfig($){
    my $href = shift @_;
    my %config = %$href;

    #print Dumper(\%config);
    for my $attr (sort keys %config){
	print STDOUT "* Attribute name : $attr\n";
	my @values = sort values %{$config{$attr}};
	my $cnt = 0;
	while (my @tmp = splice(@values,0,5)){
	    last if not @tmp;
	    print STDOUT ($cnt == 0 ? "  Allowed values : " : "                   ");
	    map {printf "%-30s ", /\s/ ? "\"$_\"" : $_} @tmp;
	    print "\n";
	    $cnt++
	}
	print "\n";
	#print STDOUT "Allowed values : " . join(", ",map {"\"$_\""} @values)."\n\n";
    }
    return 0;
}

sub HandleOptions(){

    $action = shift @ARGV;

    my %options = (addhost     => [qw(operatingsystem=s  architecture=s  hostgroup=s  environment=s  model=s  owner=s  comment=s  domain=s ptable=s medium=s)],
		   updatehost  => [qw(operatingsystem=s  architecture=s  hostgroup=s  environment=s  model=s  owner=s  comment=s  domain=s ptable=s medium=s network)],
		   showhost    => [qw(operatingsystem=s@ architecture=s@ hostgroup=s@ environment=s@ model=s@ owner=s@ comment=s@ all regexp hostname=s@)],
		   delhost     => [qw()],
		   installhost => [qw()],
		   chkhost     => [qw()],
		   showconfig  => [qw()],
    );
    HelpMessage() unless exists $options{$action};

    my %opts = (debug   => \$debug,
		dryrun  => \$dryrun,
		verbose => \$verbose);
 
    my $rc = Getopt::Long::GetOptions(\%opts,
				      (map {$_ => \$opts{(split(/=/,$_))[0]}} @{$options{$action}}),
				      "debug","dryrun","verbose",
				      "cern-user=s" => \$user_credentials{username},
	);
    HelpMessage() if not $rc;
    $verbose = 1 if $debug;
    map {delete $opts{$_} unless defined $opts{$_}} keys %opts;

    if ($action eq "addhost"){
        my @err = ();
	map {push(@err,$_) unless exists $opts{$_}} qw(operatingsystem architecture hostgroup model owner);
	if (@err){
	    map {print STDERR "[ERROR] Action \"$action\" requires mandatory option \"$_\"\n"} @err;
	    exit 1;
	}
	$opts{domain}      ||= "cern.ch";
	$opts{ptable}      ||= "RedHat default";
	$opts{environment} ||= "production";
	$opts{network}       = 1;
    }elsif ($action eq "updatehost"){
	#$opts{medium} = $opts{operatingsystem};
	#print Dumper(\%opts);
	map {delete $opts{$_} unless defined $opts{$_}} keys %opts;
	#print Dumper(\%opts);exit;

	my $cnt = 0;
	my @opt = qw(operatingsystem architecture hostgroup model owner ptable comment network environment);
	map {$cnt++ if defined $opts{$_}} @opt;
	if ($cnt == 0){
	    print STDERR "[ERROR] Action \"$action\" requires at least one of the options \"--". join("\", \"--",@opt)."\"\n";
	    exit 1;
	}
    }
				      
    return $action,%opts;
}

################################################################################################
#
# GetUserCredentials(): return username/password combination of the cern-account to be used
#                       in subsequent calls to Landb etc.
#

sub GetUserCredentials($){

    use Net::Netrc;
    use Term::ReadKey;

    my $username = shift @_;
    my $password = undef;

    my $mach = undef;
    if (defined $username){
	$mach = Net::Netrc->lookup("network.cern.ch",$username);
    }

    if ($mach){
	$password = $mach->password;
    }else{
	if (not defined $username){
	    print STDOUT "Please give the CERN username/password combination to query LANdb, talk to Foreman, etc: \n";
	    print STDOUT "   - username : ";
	    chomp($username = <STDIN>);
	    if (not defined $username){
		print STDERR "Failed to read a username, exiting\n";
		return ();
	    }
	}else{
	    print STDOUT "Please give the password for CERN account \"$username\" to query LANdb, talk to Foreman, etc: \n";
	}
	print STDOUT "   - password : ";
	ReadMode("noecho",);
	chomp($password = <STDIN>);
	ReadMode("normal");
	print "\n";
	if (not defined $password){
	    print STDERR "failed to read a password, exiting\n";
	    return ();
	}
    }

    return ($username,$password);
}

################################################################################################
#
# HelpMessage(): displays user help
#

sub HelpMessage(){

    my $script = basename $0;
    my $user = (getpwuid($<))[0];

    print <<EOH;


Usage: $script action [options] hostname [hostname]

       "action" should be one of the following

           * showhost     
           * addhost
           * delhost
           * updatehost
           * installhost
           * chkhost
           * showconfig
           * help

       Options depend on the action:

           * addhost

             --operatingsystem <name>
             --architecture <name>
             --hostgroup <name>
             --environment <name>        : default: "production"
             --model <name>
             --owner <name>
             --comment <comment string>
             --domain <name>             : default: "cern.ch"
             --ptable <name>             : default: "RedHat default"

	     note: Network information (IP and MAC addresses etc.) is retrieved from Landb

           * updatehost

             --operatingsystem <name>
             --architecture <name>
             --hostgroup <name>
             --environment <name>
             --model <name>
             --owner <name>
             --comment <comment string>
             --network                   : IP and MAC addresses are retrieved from Landb

           * showhost

             --all                       : display information for all hosts known to Foreman

             Filtering options:
               --hostname <name>
               --model <name>
               --owner <name>
               --regexp                  : interpret filtering options as regular expressions

       General options

           --cern-user <username>        : CERN account to be used for LANdb lookups and Foreman access
                                           default "$user" :)

           --verbose                     : print more output
           --debug                       : print even more output
           --dryrun                      : do not upload to AIMS

EOH

exit 0;

}

__END__

