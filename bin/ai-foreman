#!/usr/bin/env python
# This is a command line client to do CRUD operations
# on Foreman entries. It's meant to fully cover the
# functionality of its predecessor (ai-foreman-cli).
# Authors:
#  Nacho Barrientos <nacho.barrientos@cern.ch>

# Exit codes:
#   0 all operations succeeded
#   2 bad command line
#   4 Kerberos TGT not found or expired

import sys
import logging
import argparse
import argcomplete
import csv
import socket
import datetime
from dateutil import tz
from dateutil import parser as duparser
from prettytable import PrettyTable

from aitools.foreman import ForemanClient
from aitools.config import ForemanConfig

from aitools.common import configure_logging
from aitools.common import verify_kerberos_environment
from aitools.common import append_domain

from aitools.errors import AiToolsInitError, AiToolsForemanError
from aitools.errors import AiToolsAiForemanError

from aitools.completer import ForemanCompleter

SUMMARY_TABLE_FIELDS = ['Name', 'Hostgroup', 'Environment',
    'OS', 'Arch', 'Model', 'Ptable', 'Last Report']
SUMMARY_TABLE_SHOWN_FIELDS = ['Name', 'Hostgroup',
    'Environment', 'OS']
SUMMARY_TABLE_DEFAULT_SORT_KEY = 'Name'
COMMON_MODEL_OPTIONS = [
    {'short': '-e', 'long': '--environment',
        'help': "Host's environment"},
    {'short': '-c', 'long': '--hostgroup',
        'help': "Host's hostgroup"},
    {'short': '-a', 'long': '--architecture',
        'help': "Host's architecture"},
    {'short': '-p', 'long': '--ptable',
        'help': "Host's partition table"},
    {'short': '-o', 'long': '--operatingsystem',
        'help': "Host's operating system name"},
    {'short': '-m', 'long': '--medium',
        'help': "Host's operating system medium name"},
]
T_GREEN="\033[1;92m%s\033[00m"
T_RED="\033[01;91m%s\033[00m"

def parse_cmdline_args():
    """Parses and validates cmdline arguments"""
    parser = argparse.ArgumentParser()

    ##
    ## Common options
    ##

    parser.add_argument('-v', '--verbose',
        action="store_true",
        help="Be chatty")
    parser.add_argument('-d', '--dryrun',
        action="store_true",
        help="Don't execute actions that alter data")
    filter_group = parser.add_mutually_exclusive_group()
    filter_group.add_argument('-f', '--filter', type=str,
        help="Host discovery based on a Foreman search filter")
    filter_group.add_argument('-g', '--hg', type=str,
        help="Equivalent to -f hostgroup_fullname = foo.")
    filter_group.add_argument('-l', '--hl', type=str,
        help="Equivalent to -f hostgroup_fullname ~ foo.")
    filter_group.add_argument('--only-error', action='store_true',
        help="Selects only hosts in error state.")
    parser.add_argument('-s', '--sort', type=str,
        choices=SUMMARY_TABLE_FIELDS,
        default=SUMMARY_TABLE_DEFAULT_SORT_KEY,
        help="Field name to sort by (default: '%s')" % \
            SUMMARY_TABLE_DEFAULT_SORT_KEY)
    parser.add_argument('--longtable',
        action="store_true",
        help="Shows more information on the summary tables")
    parser.add_argument('--no-color',
        action="store_true",
        help="Switch colorized outputs off")

    foreman_config = ForemanConfig()
    foreman_config.add_standard_args(parser)

    subparsers = parser.add_subparsers(dest="subcommand")

    ##
    ## Addhost
    ##

    addhost_parser = subparsers.add_parser('addhost',
        help="Adds hosts")
    for option in COMMON_MODEL_OPTIONS:
        addhost_parser.add_argument(option['short'], option['long'],
            type=str, help=option['help'], required=True)
    addhost_parser.add_argument('--comment', type=str,
        help="Host's comment", default=None)
    addhost_parser.add_argument('-r', '--reset',
        help="Delete before create", action='store_true')
    addhost_parser.add_argument('-i', '--input', nargs='?',
        type=argparse.FileType('r'), default=sys.stdin)

    ##
    ## Delhost
    ##

    delhost_parser = subparsers.add_parser('delhost',
        help="Deletes hosts")
    delhost_parser.add_argument('hostname', nargs='*',
        help="Zero of more hostnames (qualified or not)").completer = \
            ForemanCompleter()

    ##
    ## Showhost
    ##

    showhost_parser = subparsers.add_parser('showhost',
        help="Shows information about hosts")
    showhost_parser.add_argument('hostname', nargs='*',
        help="Zero of more hostnames (qualified or not)").completer = \
            ForemanCompleter()

    ##
    ## Updatehost
    ##

    updatehost_parser = subparsers.add_parser('updatehost',
        help="Updates hosts")
    for option in COMMON_MODEL_OPTIONS:
        updatehost_parser.add_argument(option['short'], option['long'],
            type=str, help=option['help'])
    updatehost_parser.add_argument('--comment', type=str,
        help="Host's comment", default=None)
    updatehost_parser.add_argument('--ip', type=str,
        help="Host's IP address", default=None)
    updatehost_parser.add_argument('--mac', type=str,
        help="Host's MAC address", default=None)
    updatehost_parser.add_argument('hostname', nargs='*',
        help="Zero of more hostnames (qualified or not)").completer = \
            ForemanCompleter()

    argcomplete.autocomplete(parser)
    try:
        args = parser.parse_args()
    except IOError, error:
        parser.exit(1, str(error))

    # Can't use fqndify here as some Foreman entries
    # might not have a DNS record yet. Also, stale hosts
    # not in DNS to be deleted.
    if hasattr(args, 'hostname'):
        args.hostname = map(append_domain, args.hostname)

    return args

##
## Main functions, one per subparser
##

def addhost(foreman, args):
    ipmi_fieldnames = ['i_mac', 'i_user', 'i_pass']
    fieldnames = ['fqdn', 'ip', 'mac']
    fieldnames.extend(ipmi_fieldnames)
    reader = csv.DictReader(args.input,
        fieldnames=fieldnames, delimiter=' ')
    for record in reader:
        if args.reset:
            try:
                foreman.delhost(record['fqdn'])
                logging.info("Done")
            except AiToolsForemanError, error:
                logging.warn("Failed to delete '%s': %s (will continue)" \
                    % (record['fqdn'], error))
        try:
            logging.debug("Adding '%s'" % record['fqdn'])
            foreman.addhost(fqdn=record['fqdn'],
                environment=args.environment,
                hostgroup=args.hostgroup,
                owner=args.krb_principal.replace("@CERN.CH", ""),
                managed=True,
                operatingsystem=args.operatingsystem,
                medium=args.medium,
                architecture=args.architecture,
                comment=args.comment,
                ptable=args.ptable,
                ip=record['ip'],
                mac=record['mac'].replace('-', ':'))
        except AiToolsForemanError, error:
            logging.error("Couldn't add '%s': %s" % (record['fqdn'], error))

        if all(record[f] is not None for f in ipmi_fieldnames):
            try:
                foreman.add_ipmi_interface(record['fqdn'],
                    record['i_mac'].replace('-', ':'),
                    record['i_user'], record['i_pass'])
            except (socket.gaierror, AiToolsForemanError), error:
                logging.error("Couldn't add %s's IPMI iface': %s" % \
                    (record['fqdn'], error))

def delhost(foreman, args):
    try:
        data = get_hosts_by_filter_and_explicit_list(foreman, args)
    except AiToolsAiForemanError, error:
        logging.warn(error)
        return

    logging.info("The following hosts will be deleted:")
    print_summary_table_from_data(args, data)

    for host in data:
        try:
            foreman.delhost(host['name'])
            logging.info("Host %s deleted" % host['name'])
        except AiToolsForemanError, error:
            logging.warn("Failed to delete '%s': %s" % (host['name'], error))

def showhost(foreman, args):
    try:
        data = get_hosts_by_filter_and_explicit_list(foreman, args)
    except AiToolsAiForemanError, error:
        logging.warn(error)
        return

    print_summary_table_from_data(args, data)

def updatehost(foreman, args):
    try:
        data = get_hosts_by_filter_and_explicit_list(foreman, args)
    except AiToolsAiForemanError, error:
        logging.warn(error)
        return

    logging.info("The following %d host(s) will be updated:" % len(data))
    print_summary_table_from_data(args, data)

    candidates = [x['long'].replace('--', '') for x in COMMON_MODEL_OPTIONS]
    candidates.extend(['ip', 'mac'])
    to_update = dict([(k, getattr(args, k)) for k in candidates])

    errors_table = PrettyTable(['Host', 'Error'])
    errors_table.align = 'l'
    for count, host in enumerate(data):
        try:
            foreman.updatehost(host['name'], **to_update)
            print_progress(count, len(data))
        except AiToolsForemanError, error:
            errors_table.add_row([host['name'], error])

    print_progress(len(data), len(data))

    # Apparently there's no clean way to get the number of rows :/
    if len(errors_table._rows) > 0:
        logging.warn(T_RED % "\nSome hosts failed to update:")
        print errors_table.get_string()
    else:
        logging.info(T_GREEN % "\nAll hosts were successfully updated :)")

##
## Helper functions
##

def get_hosts_by_filter_and_explicit_list(foreman, args):
    data = []
    if args.hg:
        args.filter = "hostgroup_fullname = %s" % args.hg

    if args.hl:
        args.filter = "hostgroup_fullname ~ %s" % args.hl

    if args.only_error:
        args.filter = ("last_report > \"1505 minutes ago\" and (status.failed > 0"
            " or status.failed_restarts > 0)")

    if args.filter:
        logging.debug("Searching for hosts matching '%s'" % args.filter)
        data.extend(foreman.search_query("hosts", args.filter))

    if args.hostname:
        found = [host['name'] for host in data]
        logging.debug("Gathering information for: %s" % ", ".join(args.hostname))
        for fqdn in args.hostname:
            if fqdn in found:
                continue # Just to avoid duplicates
            try:
                data.append(foreman.gethost(fqdn, toexpand=[]))
            except AiToolsForemanError, error:
                logging.warn(error)

    if not data:
        raise AiToolsAiForemanError("All filters processed, nothing to show :/")

    return data

def print_summary_table_from_data(args, data):
    table = PrettyTable(SUMMARY_TABLE_FIELDS)
    table.align = 'l'
    unix_epoch = datetime.datetime.fromtimestamp(0, tz=tz.tzlocal())
    for host in data:
        last_report = unix_epoch
        if host['last_report']:
            last_report = duparser.parse(host['last_report'])
        last_report = last_report.astimezone(tz.tzlocal())
        table.add_row([
            host['name'],
            host['hostgroup_name'],
            host['environment_name'],
            host['operatingsystem_name'],
            host['architecture_name'],
            host['model_name'],
            host['ptable_name'],
            last_report])

    if not args.longtable:
        print table.get_string(sortby=args.sort,
            fields=SUMMARY_TABLE_SHOWN_FIELDS)
    else:
        print table.get_string(sortby=args.sort)

def print_progress(count, total):
    progress = int((float(count)/total)*100)
    sys.stdout.write("\rIn progress... %d%% done" % progress)
    sys.stdout.flush()

def main():
    """Application entrypoint"""
    args = parse_cmdline_args()
    fconfig = ForemanConfig()
    fconfig.read_config_and_override_with_pargs(args)

    configure_logging(args)

    try:
        args.krb_principal = verify_kerberos_environment()
    except AiToolsInitError, error:
        logging.error("TGT not found or expired. Exiting...")
        return 4

    foreman = ForemanClient(dryrun=args.dryrun,
        deref_alias=args.dereference_alias)

    if args.no_color:
        global T_GREEN, T_RED
        T_GREEN = T_RED = "%s"

    globals()[args.subcommand](foreman, args)

    return 0

if __name__ == '__main__':
    sys.exit(main())
